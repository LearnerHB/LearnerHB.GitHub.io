<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bing&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c9223a37a5cee0efbf7803d82948b304</icon>
  <subtitle>Innovating Today. Imagining Tomorrow.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bingcs.com/"/>
  <updated>2021-07-11T09:22:13.156Z</updated>
  <id>http://bingcs.com/</id>
  
  <author>
    <name>Hu Bing</name>
    <email>hubingcs@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://bingcs.com/2021/07/11/dynamic-planning/"/>
    <id>http://bingcs.com/2021/07/11/dynamic-planning/</id>
    <published>2021-07-11T06:41:14.000Z</published>
    <updated>2021-07-11T09:22:13.156Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>[toc]</p><p>（UPDATING……）</p><h2 id="动态规划简介"><a href="#动态规划简介" class="headerlink" title="动态规划简介"></a>动态规划简介</h2><h3 id="动态规划背景"><a href="#动态规划背景" class="headerlink" title="动态规划背景"></a>动态规划背景</h3><p>动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。其不是一种具体的算法，而是一种算法思想：把问题划分成子问题，通过解决子问题来进一步得出原问题的解。</p><p>应用这种算法思想解决问题，对子问题和原问题的关系、子问题之间的关系有一定的要求，可以归纳为两点：<strong>最优子结构</strong>、<strong>重复子问题</strong>。</p><h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>最优子结构规定了子问题和原问题之间的关系：一个问题的最优解是由他的各个子问题的最优解决定的。</p><p>将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。在解题中一般用状态转移方程描述这种组合。例如原问题的解为f(n)，其中f(n)也叫状态，状态转移方程f(n)=f(n-1)+f(n-2)描述了一种（注意仅是一种）原问题与子问题的组合。不同的的选择可能对应不同的子问题或者不同的组合方式，找到了最优子结构之后便能够推导出一个状态转移方程，进而写出问题的递归实现方法。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-11-070043.png" alt="image-20210711150042190"></p><h4 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h4><p>重复子问题规定的是子问题与子问题的关系。递归寻找每个子问题的最优解时可能会遇到更小的子问题重叠出现在子问题里，于是会产生很多冗余的重叠计算。动态规划可以保证每个重叠的子问题只被求解一次，减少重复计算。</p><p>重复子问题不是保证解的正确性所必须的，但若递归求解子问题时没有出现重复子问题，则没有必要用动态规划，直接用普通的递归即可。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-11-070804.png" alt="image-20210711150804382"></p><p>解决动态规划问题的核心：<strong>找出子问题以及子问题和原问题之间的关系。</strong></p><p>找到子问题以及子问题和原问题的关系就可以进行递归求解，但重叠的子问题给递归带来许多重复计算，若可事先确定子问题的范围就可以建表存储子问题的答案。</p><h4 id="Key-Point"><a href="#Key-Point" class="headerlink" title="Key Point"></a>Key Point</h4><ol><li>证明问题的解决方案中包含一种选择，可以使问题被分解成一个或多个子问题；</li><li>设计子问题的递归描述方式；</li><li>证明对原问题的最优解包含了对所有子问题的最优解；</li><li>(option) 证明子问题是重叠的（无重叠则也可直接用递归）。</li></ol><h3 id="解决动态规划问题的思考过程"><a href="#解决动态规划问题的思考过程" class="headerlink" title="解决动态规划问题的思考过程"></a>解决动态规划问题的思考过程</h3><p>以题目 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300.最长递增子序列</a> 为例。</p><p>描述：</p><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是4。</span><br></pre></td></tr></table></figure><h4 id="0-考虑缩小问题规模"><a href="#0-考虑缩小问题规模" class="headerlink" title="0. 考虑缩小问题规模"></a>0. 考虑缩小问题规模</h4><p>问题规模减小的方式有多种，一些典型的方法如：线性，区间，树形。数组上常用的有两种：减半、减一。</p><ul><li>每次减少一半：原问题分解成[10,9,2,5]和[3,7,101,18]，两个子问题最优解分别为[2,5]和[3,7,101]，但找不到合适的组合方式把子问题的最优解组合成[2,5,7,101]；</li><li>每次减少一个：记f(n)为第n个数据的最长子序列，每次减少一个，将原问题分为f(n-1), f(n-2), … f(1)，共 n-1 个子问题，分别的解如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[10, 9, 2, 5, 3, 7, 101] -&gt; [2, 5, 7, 101]</span><br><span class="line">[10, 9, 2, 5, 3, 7] -&gt; [2, 5, 7]</span><br><span class="line">[10, 9, 2, 5, 3] -&gt; [2, 3]</span><br><span class="line">[10, 9, 2, 5] -&gt; [2, 5]</span><br><span class="line">[10, 9, 2] -&gt; [2]</span><br><span class="line">[10, 9] -&gt; [9]</span><br><span class="line">[10] -&gt; [10]</span><br></pre></td></tr></table></figure><p>可以有的思路：记f(n)为以第n个数结尾的最长子序列。f(n)的最优解可以描述为，子数组中最后一个数字小于 f(n) 的所有子问题的最优解中的最大值，再加上1（也就是子序列再加一个f(n) ）。</p><p>状态转移方程：</p><p><code>f(n) = max_f(i) + 1</code>，其中 i &lt; n 且 a[i] &lt; a[n]</p><p><strong>总结：解决DP问题的关键</strong></p><ul><li>如何定义f(n)</li><li>如何通过f(1)，f(2)…… f(n-1) 推导出 f(n)，即状态转移方程</li></ul><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h4><p>有了状态转移方程，已经可以写出递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">      a = <span class="built_in">max</span>(a, f(nums, j)+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-自顶向下（记忆化）"><a href="#2-自顶向下（记忆化）" class="headerlink" title="2. 自顶向下（记忆化）"></a>2. 自顶向下（记忆化）</h4><p>递归解法需要很多重复计算，如果有方法可以避免这些重复计算，可以节省大量时间。在递归地求解子问题过程中，将结果保存到一个表dp里，在后续求解子问题中如果遇到求过结果的子问题，直接查表去得到答案而不计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(dp[i], res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/xceyqr/" target="_blank" rel="noopener">动态规划精讲1 - 力扣</a></li><li><a href="https://leetcode-cn.com/leetbook/detail/dynamic-programming-2-plus/" target="_blank" rel="noopener">动态规划精讲2 - 力扣</a></li><li><a href="https://leetcode-cn.com/leetbook/detail/path-problems-in-dynamic-programming/" target="_blank" rel="noopener">DP - 路径问题 - 力扣</a></li></ol>]]></content>
    
    <summary type="html">
    
      from LeetBook.
    
    </summary>
    
      <category term="Algorithm" scheme="http://bingcs.com/categories/Algorithm/"/>
    
    
      <category term="Dynamic Planning" scheme="http://bingcs.com/tags/Dynamic-Planning/"/>
    
  </entry>
  
  <entry>
    <title>Journey of Kubernetes(k8s)</title>
    <link href="http://bingcs.com/2021/06/28/k8s-learning/"/>
    <id>http://bingcs.com/2021/06/28/k8s-learning/</id>
    <published>2021-06-28T12:14:20.000Z</published>
    <updated>2021-07-05T02:56:06.068Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Kubernetes-K8s-是什么"><a href="#Kubernetes-K8s-是什么" class="headerlink" title="Kubernetes(K8s)是什么"></a>Kubernetes(K8s)是什么</h2><p><a href="https://kubernetes.io/zh/" target="_blank" rel="noopener">Kubernetes</a> 是用于自动部署，扩展和管理容器化应用程序的开源系统。它可以帮助用户省去应用容器化过程中的许多手动部署和扩展操作。你可以将Linux容器的多组主机聚集在一起，由Kubernetes来轻松高效地管理这些集群。<strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。</p><p>当我们把容器部署到生产环境或者扩展成多个应用，我们显然需要许多托管在相同位置的容器来协同提供各种服务，随着这些容器的积累，环境中容器的数量会急剧增加，复杂度随之增长。Kubernetes通过将容器分类成 容器集(pod)，解决了容器增殖带来的许多问题。容器集为分组容器增加了一个抽象层，可以帮助我们调用工作负载，并为这些容器提供所需的联网和存储服务，而Kubernetes的其他部分可以帮助我们在这些容器集之间达成负载均衡，同时确保运行正确数量的容器来充分支持我们的工作负载。</p><h2 id="K8s相关术语"><a href="#K8s相关术语" class="headerlink" title="K8s相关术语"></a>K8s相关术语</h2><p><strong>主机（Master）：</strong> 用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。</p><p><strong>节点（Node）：</strong>负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制。</p><p><strong>容器集（Pod）：</strong>被部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。</p><p><strong>复制控制器（Replication controller）：</strong>用于控制应在集群某处运行的完全相同的容器集副本数量。</p><p><strong>服务（Service）：</strong>将工作内容与容器集分离。Kubernetes 服务代理会自动将服务请求分发到正确的容器集——无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉。</p><p><strong>Kubelet：</strong>运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。</p><p><strong>kubectl：</strong> Kubernetes 的命令行配置工具。</p><h2 id="K8s集群架构"><a href="#K8s集群架构" class="headerlink" title="K8s集群架构"></a>K8s集群架构</h2><p>一个K8s集群可以可视化为两个部分：控制平面和计算设备（或节点）。每个节点都是自己的Linux环境，可以是物理机或者虚拟机，每个节点都运行由若干容器组成的容器集。</p><p>如下架构图显示K8s集群的各部分之间的联系。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-06-29-023053.png" alt="image-20210629103052447"></p><ul><li><p>K8s集群的神经中枢：控制平台 Control plane</p><ul><li>K8s集群API：kube-apiserver</li><li>K8s调度程序：kube-scheduler</li><li>K8s控制器：kube-controller-manager</li><li>键值存储数据库 etcd</li></ul></li><li><p>K8s节点：Compute machines</p><ul><li>容器集Pod</li><li>容器运行时引擎：如Docker，但K8s也支持其他诸如rkt和CRI-O</li><li>kubelet：与控制平面通信的微型应用，可确保容器在容器集内运行</li><li>kube-proxy：用于优化K8s网络服务的网络代理</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.redhat.com/zh/topics/containers/kubernetes-architecture" target="_blank" rel="noopener">K8s 原理：Kubernetes 架构解析</a></li></ol>]]></content>
    
    <summary type="html">
    
      k8s基础
    
    </summary>
    
      <category term="Container" scheme="http://bingcs.com/categories/Container/"/>
    
    
      <category term="Kubernetes" scheme="http://bingcs.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Journey of Docker</title>
    <link href="http://bingcs.com/2021/06/25/docker-learning/"/>
    <id>http://bingcs.com/2021/06/25/docker-learning/</id>
    <published>2021-06-25T07:39:04.000Z</published>
    <updated>2021-07-05T02:56:14.820Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>[toc]</p><p>（填坑中……）</p><h2 id="为什么要有Docker？"><a href="#为什么要有Docker？" class="headerlink" title="为什么要有Docker？"></a>为什么要有Docker？</h2><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><h2 id="Docker简明教程"><a href="#Docker简明教程" class="headerlink" title="Docker简明教程"></a>Docker简明教程</h2><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h2 id="Docker微服务实践"><a href="#Docker微服务实践" class="headerlink" title="Docker微服务实践"></a>Docker微服务实践</h2><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p><a href="https://github.com/docker/compose" target="_blank" rel="noopener">Compose </a>是Docker公司推出的一个工具软件，可以管理多个Docker容器组成一个应用。你需要定义一个YAML格式的配置文件<code>docker-compose.yml</code>，写好多个容器之间的调用关系。然后只需要一个命令就可以同时启动、关闭这些容器。</p><p>使用Compose的步骤基本上可以概括为：</p><ol><li>用一个<code>Dockerfile</code>文件定义你的app的环境</li><li>用一个<code>docker-compose.yml</code>文件定义你的服务，使之可以运行在同一个隔离的环境中</li><li>运行 <code>docker compose up</code> 命令来开启你的服务</li></ol><p>一个 <code>docker-compose.yml</code> 文件长这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.9"</span>  <span class="comment"># optional since v1.27.0</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>你可以在 <a href="https://github.com/docker/awesome-compose" target="_blank" rel="noopener">这里</a> 找到一些官方推荐的compose例子。</p><h2 id="容器安全风险与防范"><a href="#容器安全风险与防范" class="headerlink" title="容器安全风险与防范"></a>容器安全风险与防范</h2><p>（听组里大佬的分享，做一下简单的笔记）</p><h3 id="1-容器发展历程"><a href="#1-容器发展历程" class="headerlink" title="1. 容器发展历程"></a>1. 容器发展历程</h3><p><strong>chroot</strong> (1979): Unix V7 chroot技术的引进开启了进程隔离的大门</p><p><strong>LXC</strong> (2008): 第一个完善的Linux容器管理实现方案</p><p><strong>Docker</strong> (2013): 引入了整个管理容器的生态docker</p><p><strong>Rocket</strong> (2014): rkt想要解决Docker中发现的一些安全缺陷</p><p><strong>Windows容器</strong> (2016): Windows Server 2016原生支持Docker容器</p><h3 id="2-镜像和容器"><a href="#2-镜像和容器" class="headerlink" title="2. 镜像和容器"></a>2. 镜像和容器</h3><p><strong>镜像(image)</strong>：一种特殊的文件系统，包含有程序、库、配置文件等文件，包括一些环境变量。镜像不包含任何动态数据，其内容在构建之后也不会改变。</p><p><strong>容器(Container)</strong>：镜像运行起来的实例，一个镜像可以有多个实例，包括动态数据。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-090416.png" alt="image-20210701170415699"></p><h3 id="3-容器的优势"><a href="#3-容器的优势" class="headerlink" title="3. 容器的优势"></a>3. 容器的优势</h3><ul><li>一致的环境：软件依赖、基础系统依赖</li><li>任何地方运行：Linux/Windows/Mac/虚拟机/裸机</li><li>隔离：OS级别虚拟化，CPU、内存、网络资源隔离</li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-090730.png" alt="image-20210701170730301"></p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-090945.png" alt="image-20210701170934477"></p><h3 id="4-容器编排系统"><a href="#4-容器编排系统" class="headerlink" title="4. 容器编排系统"></a>4. 容器编排系统</h3><p>容器编排系统将用户镜像自动化部署到集群环境中，并且管理容器工作，可以监控容器运行状态，自动扩缩容、升级、回滚等。常见的容器编排系统如 Kubernetes。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-06-29-023053.png" alt="image-20210629103052447"></p><center>一个Kubernetes集群</center><h3 id="5-容器安全"><a href="#5-容器安全" class="headerlink" title="5. 容器安全"></a>5. 容器安全</h3><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li>Graboid蠕虫</li></ol><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-112250.png" alt="加密挖矿蠕虫病毒活动概览"></p><center>加密挖矿蠕虫病毒活动概览</center><p><a href="https://shodan.io/" target="_blank" rel="noopener">Shodan</a>的快速调查显示，有2,000多个Docker Engine以不安全的方式暴露于互联网。无需任何身份验证或授权，攻击者就可以完全控制Docker Engine（社区版）和主机。恰恰是抓住了这一入口，攻击者才会部署并传播这一蠕虫病毒。上图标明了该恶意软件的分发和传播方式。攻击者入侵了一个未受保护的Docker daemon，运行从Docker Hub中提取的恶意Docker容器，从C2服务器下载一些脚本和易受攻击的主机列表，并反复选取下个目标传播蠕虫。</p><ol start="2"><li>Dirty Cow</li></ol><p><a href="https://github.com/gbonacini/CVE-2016-5195" target="_blank" rel="noopener">CVE-2016-5195</a></p><p>该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><h4 id="容器安全架构"><a href="#容器安全架构" class="headerlink" title="容器安全架构"></a>容器安全架构</h4><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-115325.png" alt="image-20210701195325128"></p><center>容器安全架构</center><h4 id="安全容器技术"><a href="#安全容器技术" class="headerlink" title="安全容器技术"></a>安全容器技术</h4><ul><li><p>利用虚拟化技术增强容器安全性</p><ul><li>Google gVisor</li><li>IBM Nabla</li><li>Openstack Kata</li><li>Vmware vSphere Integrated Containers</li></ul></li><li><p>利用硬件隔离</p><ul><li>SGX</li></ul></li></ul><h3 id="6-镜像安全"><a href="#6-镜像安全" class="headerlink" title="6. 镜像安全"></a>6. 镜像安全</h3><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><ul><li>镜像周期<ul><li>用户镜像的数据来源多样化（dockerhub、内部镜像库）</li><li>开源，每个人均可访问，若有安全问题则传播加速</li></ul></li><li>开源框架<ul><li>误报率高</li></ul></li></ul><h4 id="问题和风险"><a href="#问题和风险" class="headerlink" title="问题和风险"></a>问题和风险</h4><ul><li>镜像篡改</li><li>恶意镜像</li><li>未授权访问</li></ul><h4 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h4><ul><li>安全通信</li><li>访问控制</li><li>镜像存储隔离</li><li>镜像漏洞，恶意程序，配置扫描</li><li>镜像加密，签名</li></ul><h3 id="7-集群安全"><a href="#7-集群安全" class="headerlink" title="7. 集群安全"></a>7. 集群安全</h3><h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><ul><li>Master 节点被控制</li><li>内部API开放</li><li>集群信息泄露</li><li>凭据安全保存</li></ul><h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p><a href="https://github.com/aquasecurity/kube-bench" target="_blank" rel="noopener">Kube-bench</a> 用来检查Kubernetes是否被安全部署。</p><h3 id="8-运行时安全"><a href="#8-运行时安全" class="headerlink" title="8. 运行时安全"></a>8. 运行时安全</h3><ul><li>Selinux</li><li>LSM-Apparmor</li><li>ebpf</li></ul><h3 id="9-容器网络安全"><a href="#9-容器网络安全" class="headerlink" title="9. 容器网络安全"></a>9. 容器网络安全</h3><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><ol><li>CNM模型（Container Network Model）</li></ol><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-121547.png" alt="image-20210701201547008"></p><center>CNM模型</center><p>CNM模型主要通过 Network Sanbox , Endpoint 和 Network 这三个朱建进行实现</p><ul><li>Network Sanbox: 容器内部的网络栈, 包括网络接口,路由表, dns 等配置,一个 network sanbox 可以包含多个 endpoint</li><li>endpoint: 用于将容器内的sanbox 与外部网络相关联的网络接口. 可用使用veth ovs , 内部port 等技术实现</li><li>network: 可以直接互联的endpoint 集合. 可以通过linux 网桥, vlan等技术实现.</li></ul><ol start="2"><li>CNI模型</li></ol><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-121730.png" alt="image-20210701201729741"></p><p>CNI 的规范比较小巧。它规定了一个容器runtime和网络插件之间的简单的契约。这个契约通过JSON的语法定义了CNI插件所需要提供的输入和输出。</p><p>一个容器可以被加入到被不同插件所驱动的多个网络之中。一个网络有自己对应的插件和唯一的名称。CNI 插件需要提供两个命令：一个用来将网络接口加入到指定网络，另一个用来将其移除。这两个接口分别在容器被创建和销毁的时候被调用。</p><h4 id="风险和防范"><a href="#风险和防范" class="headerlink" title="风险和防范"></a>风险和防范</h4><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-07-01-113945.png" alt="image-20210701193945324"></p><p>风险：</p><ul><li>南北向的外部入侵</li><li>东西向的横向入侵</li><li>性能开销</li></ul><p>应对措施</p><ul><li>细粒度容器之间的网络访问控制。例如：App1可以访问App3</li><li>容器网络拓扑</li><li>Ebpf技术</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker入门教程</a>, by 阮一峰</li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="noopener">Docker微服务教程</a>, by 阮一峰</li><li><a href="https://www.sitepoint.com/how-to-manually-build-docker-containers-for-wordpress/" target="_blank" rel="noopener">How to Manually Build Docker Containers for WordPress</a>, by Aleksander Koko</li><li><a href="https://www.sitepoint.com/how-to-use-the-official-docker-wordpress-image/" target="_blank" rel="noopener">How to Use the Official Docker WordPress Image</a>, by Aleksander Koko</li><li><a href="https://www.sitepoint.com/deploying-wordpress-with-docker/" target="_blank" rel="noopener">Deploying WordPress with Docker</a>, by Aleksander Koko</li><li><a href="https://www.paloaltonetworks.com/blog/2019/10/graboid-first-ever-cryptojacking-worm/?lang=zh-hans" target="_blank" rel="noopener">Docker Hub镜像中首次发现名为Graboid的加密挖矿蠕虫病毒</a></li></ol>]]></content>
    
    <summary type="html">
    
      Docker相关学习
    
    </summary>
    
      <category term="Container" scheme="http://bingcs.com/categories/Container/"/>
    
    
      <category term="Docker" scheme="http://bingcs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Shell杂谈</title>
    <link href="http://bingcs.com/2021/06/16/learning-shell/"/>
    <id>http://bingcs.com/2021/06/16/learning-shell/</id>
    <published>2021-06-16T03:01:21.000Z</published>
    <updated>2021-06-17T12:02:37.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用内容小记"><a href="#常用内容小记" class="headerlink" title="常用内容小记"></a>常用内容小记</h2><ul><li>echo 输出</li><li>readonly 标记只读变量</li><li>unset 删除变量</li><li>单引号<ul><li>单引号中变量无效，内部字符原样输出；</li><li>单引号字符串中不能出现单独的一个单引号，即便使用了转义字符，但可以成对出现</li></ul></li><li>双引号<ul><li>双引号里可以有变量；</li><li>双引号里可以出现转义字符</li></ul></li><li>提取子字符串：${string:1:4} 从位置1（第二个位置）开始截取4个字符</li><li>查找子字符串：<code>expr index &quot;$string&quot; io</code>  查找字符i或o的位置，哪个先出现就计算哪个</li><li>数组：<ul><li>定义 array1=(value0 value1)   赋值 array1[0]=value3  读取 ${array1[n]}</li><li>获取所有元素 echo ${array_name[@]}</li></ul></li><li>注释： 单行#     多行:&lt;&lt;EOF xxxx EOF  或 :&lt;&lt;’  xxxx  ‘    或 :&lt;&lt;! xxxx !</li><li>关系运算符 只支持数字或值为数字的字符串-eq -ne -gt -lt -ge -le</li><li>布尔运算符 ! -o -a</li><li>逻辑运算符 &amp;&amp; ||</li><li>字符串运算符 = != -z -n $</li><li>文件测试运算符 -r file 检查file是否可读 等等……</li><li>echo 输出<ul><li>显示命令执行结果，使用反引号 `</li><li>单引号包括的字符串会原样输出，没有转义</li></ul></li><li>printf 输出</li><li>test用于检查某个条件是否成立，可以进行 数值、字符、文件 三个方面的测试</li><li>if then elif then else 常与test结合使用</li><li>for var in item1 item2; do command1; command2; done;</li><li>Let 执行表达式 let “int++”</li><li>case esac</li><li>函数 funname(){}</li><li>函数参数<ul><li>$10不能获取第10个参数，要用${10}</li><li>$#参数个数；</li><li>$*以一个单字符串显示所有向脚本传递的参数；</li><li>$$脚本运行的当前进行ID号；</li><li>$!后台运行的最后一个进程ID号</li><li>$@与$*相同，但是使用时加引号，并在引号中返回各个参数</li><li>$-显示Shell使用的当前选项，与set命令功能相同</li><li>$? 显示最后命令的退出状态。0表示没有错误，其他值表示有错误；$?仅对上一条指令负责，一旦函数返回后没有立即保存入参数，那么其返回值将不能再通过$?获得。</li><li>输出重定向: &gt;  ; 输出以追加的方式重定向: &gt;&gt; ; 输出文件m与n合并 n &gt;&amp; m ; </li></ul></li></ul><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>一种处理文本文件的语言，强大的文本分析工具。主要用于行处理。</p><blockquote><p>grep 更适合单纯的查找或匹配文本</p><p>sed 更适合编辑匹配到的文本</p><p>awk 更适合格式化文本，对文本进行较复杂格式处理</p></blockquote><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [-F filed_separator] <span class="string">'&#123;[pattern] action&#125;'</span> &#123;filenames&#125;   <span class="comment"># 行匹配语句 awk '' 只能用单引号</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># log.txt文本内容如下：</span></span><br><span class="line">1 : This is a <span class="built_in">test</span>.</span><br><span class="line">2 : The number indicates the index of line.</span><br><span class="line">3 : We are going to learn the basic usage of awk.</span><br><span class="line">4 : Let<span class="string">'s list some fruits at first.</span></span><br><span class="line"><span class="string">5 : Apple, Banana, Orange &amp; Pear.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># log2.txt文本内容如下：</span></span><br><span class="line"><span class="string">Apple:Banana:Potato</span></span><br><span class="line"><span class="string">Apple : Banana : Potato</span></span><br><span class="line"><span class="string">Apple: Banana: Potato</span></span><br><span class="line"><span class="string">Apple,Banana,Potato</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每行按空格或TAB分割，输出文本中1 2 5项。参数之间用,分割的话输出会用空格分割。</span></span><br><span class="line">$ awk <span class="string">'&#123;print $1,$2,$5&#125;'</span> log.txt</span><br><span class="line">1 : a</span><br><span class="line">2 : indicates</span><br><span class="line">3 : going</span><br><span class="line">4 : some</span><br><span class="line">5 : Orange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line">$ awk <span class="string">'&#123;printf "%-8s %-10s\n",$1,$3&#125;'</span> log.txt </span><br><span class="line">1        This      </span><br><span class="line">2        The       </span><br><span class="line">3        We        </span><br><span class="line">4        Let<span class="string">'s     </span></span><br><span class="line"><span class="string">5        Apple,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 指定域分隔符 -F 未加这个参数的话就是默认用空格作为分割</span></span><br><span class="line"><span class="string">$ awk -F: '</span>&#123;<span class="built_in">print</span> <span class="variable">$1</span><span class="variable">$2</span>&#125;<span class="string">' log2.txt</span></span><br><span class="line"><span class="string">AppleBanana</span></span><br><span class="line"><span class="string">Apple  Banana </span></span><br><span class="line"><span class="string">Apple Banana</span></span><br><span class="line"><span class="string">Apple,Banana,Potato</span></span><br><span class="line"><span class="string">$ awk -F, '</span>&#123;<span class="built_in">print</span> <span class="variable">$1</span><span class="variable">$2</span>&#125;<span class="string">' log2.txt</span></span><br><span class="line"><span class="string">Apple:Banana:Potato</span></span><br><span class="line"><span class="string">Apple : Banana : Potato</span></span><br><span class="line"><span class="string">Apple: Banana: Potato</span></span><br><span class="line"><span class="string">AppleBanana</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>除了 <code>$+数字</code> 表示某个字段，awk还提供其他一些变量。常用的有NF和NR。</p><p>变量<code>NF</code>表示当前行有多少个字段，因此<code>$NF</code>就代表最后一个字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'this is a test'</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>变量<code>NR</code>表示当前处理的是第几行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F <span class="string">':'</span> <span class="string">'&#123;print NR ") " $2&#125;'</span> log.txt</span><br><span class="line">1)  This is a <span class="built_in">test</span>.</span><br><span class="line">2)  The number indicates the index of line.</span><br><span class="line">3)  We are going to learn the basic usage of awk.</span><br><span class="line">4)  Let<span class="string">'s list some fruits at first.</span></span><br><span class="line"><span class="string">5)  Apple, Banana, Orange &amp; Pear.</span></span><br></pre></td></tr></table></figure><p>其他变量如：</p><ul><li><code>FILENAME</code>：当前文件名</li><li><code>FS</code>：字段分隔符，默认是空格和制表符。</li><li><code>RS</code>：行分隔符，用于分割每一行，默认是换行符。</li><li><code>OFS</code>：输出字段的分隔符，用于打印时分隔字段，默认为空格。</li><li><code>ORS</code>：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li><li><code>OFMT</code>：数字输出的格式，默认为<code>％.6g</code>。</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>awk 还提供了一些方便的内置函数。</p><ul><li><code>toupper()</code>：字符转为大写。</li><li><code>tolower()</code>：字符转为小写。</li><li><code>length()</code>：返回字符串长度。</li><li><code>substr()</code>：返回子字符串。</li><li><code>sin()</code>：正弦。</li><li><code>cos()</code>：余弦。</li><li><code>sqrt()</code>：平方根。</li><li><code>rand()</code>：随机数。</li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>awk允许指定输出条件，只输出符合条件的行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'条件 动作'</span> 文件名</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F <span class="string">':'</span> <span class="string">'/Apple/ &#123;print $1,$2&#125;'</span> log.txt <span class="comment"># 只输出包含Apple字段的行</span></span><br><span class="line">5   Apple, Banana, Orange &amp; Pear.</span><br><span class="line">$ awk -F <span class="string">':'</span> <span class="string">'NR%2==1 &#123;print $0&#125;'</span> log.txt <span class="comment"># 只输出奇数行</span></span><br><span class="line">1 : This is a <span class="built_in">test</span>.</span><br><span class="line">3 : We are going to learn the basic usage of awk.</span><br><span class="line">5 : Apple, Banana, Orange &amp; Pear.</span><br><span class="line">$ awk -F <span class="string">':'</span> <span class="string">'$1=="1 " &#123;print $0&#125;'</span> log.txt<span class="comment"># 输出第一个字段等于指定值的行</span></span><br><span class="line">1 : This is a <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>awk提供了if结构，用于编写复杂的条件。if结构还可以指定else部分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F <span class="string">':'</span> <span class="string">'&#123;if ($1&gt;"2 ") print $0; else print "---"&#125;'</span> log.txt</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">3 : We are going to learn the basic usage of awk.</span><br><span class="line">4 : Let<span class="string">'s list some fruits at first.</span></span><br><span class="line"><span class="string">5 : Apple, Banana, Orange &amp; Pear.</span></span><br></pre></td></tr></table></figure><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>(Coming soon……)</p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>(Coming soon……)</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>(Coming soon……)</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>(Coming soon……)</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.gnu.org/software/gawk/manual/html_node/index.html#SEC_Contents" target="_blank" rel="noopener">The GNU Awk User’s Guide</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/11/awk.html" target="_blank" rel="noopener">awk入门教程-阮一峰的网络日志</a></p><p><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Linux awk命令-菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      Shell编程常用的一些指令
    
    </summary>
    
      <category term="Tech" scheme="http://bingcs.com/categories/Tech/"/>
    
    
      <category term="Shell" scheme="http://bingcs.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Journey of Go</title>
    <link href="http://bingcs.com/2021/05/19/go-learning/"/>
    <id>http://bingcs.com/2021/05/19/go-learning/</id>
    <published>2021-05-19T13:11:51.000Z</published>
    <updated>2021-07-05T05:05:05.484Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>(更新中……)</p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><ul><li>内建new函数，是预定义函数而不是关键字，可以将new这个名字重新定义为别的类型</li><li>Go自动垃圾收集器 &amp; 变量生命周期</li><li>元组赋值，右边的表达式会先分别计算，再统一赋值给左边</li><li>类型type：每个类型T对应的T(x)类型转换适用于两个类型的底层基础类型相同或二者都是指向相同底层结构的指针类型</li><li>区分作用域和生命周期：作用域是编译时候的概念，生命周期是运行时候的概念</li></ul><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><ul><li>字符串：字符串内部数据不可修改；原生字符串 ``代替””，可跨越多行，适合编写正则表达式等需要包含多个反斜杠的语句</li><li>UTF-8：依赖其优良设计，可以不用解码直接测试一个字符串是否是另一个字符串的前缀：HasPrefix/HasSuffix，或是包含子串测试</li><li>bytes包和strings包的函数：Contains, Count, Fields, HasPrefix, Index, Join </li><li>bytes包的Buffer类型bytes.Buffer，WriteRune / WriteBytes方法</li><li>strconv包：Itoa, FormatInt, FormatUnit, Atoi, ParseInt, ParseUint</li><li>itoa常量生成器</li><li>无类型常量被赋值给一个变量的时候会被隐式转换为对应的类型</li></ul><h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><ul><li>var q [3]int = [3]int{1,2,3     q := […]int{1,2,3}  r := […]int{99:-1} 未指定初始值的用0初始化,99到-1，其余都是0</li><li>数组长度是数组类型的一个组成部分；由于数组长度的限制条件，所以很少用作函数参数，一般用slice来代替数组</li></ul><h3 id="Slice切片"><a href="#Slice切片" class="headerlink" title="Slice切片"></a>Slice切片</h3><ul><li>变长的序列；三部分组成：指针、长度len、容量cap (一般slice开始位置到底层数据的结尾位置)</li><li>和数组不同的是，Slice之间不能比较，不能用-=来判断两个slice是否具有全部相等元素</li><li>切片唯一合法的比较操作是和nil比较。判断slice是否为空应该用len(s)==0判断而不是s==nil。</li><li>make([]T, len) 和 make([]T, len, cap)的区别</li><li>append函数；copy函数；append模拟stack；copy函数实现删除slice中某元素</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>:= make(map[string]int) 或 := map[string]int{}来创建；内置delete函数可以删除元素delete(ages, “Alice”)</li><li>map中的元素并不是变量，所以不能对map的元素进行取址 _ = &amp;ages[“bob”]会报错</li><li>nil值的map存入元素将导致panic异常</li><li>map[string]bool实现set的功能（Go中没有Set类型）</li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li>命名为S的结构体类型内不能包含S类型的成员，但可以包含*S指针类型的成员，由此可以创建递归的数据结构如链表和树</li><li>结构体作为参数传函数的时候，如果希望能够更改结构体成员，必须用指针传入，因为Go中所有函数参数都是值拷贝传入</li><li>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的；可比较的结构体类型和其他可比较类型一样，可以用语map 的key类型</li><li>匿名成员，匿名嵌入，直接访问叶子属性；但结构体字面值并没有简短表示匿名成员的方法</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="Defferred函数"><a href="#Defferred函数" class="headerlink" title="Defferred函数"></a>Defferred函数</h3><p>普通函数或方法前加上关键字defer，当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后面的函数才会被执行，不论包含defer的语句是正常return还是panic导致嗯异常结束。</p><p>defer语句常用于处理成对的操作，如打开/关闭，连接/断开连接，加锁/释放锁。通过defer机制来保障资源的正常释放，释放资源的defer语句应该直接跟在请求资源的语句后。</p><ol><li>借助Defer机制观察函数的返回值：由于defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"double(%d) = %d\n"</span>, x,result) &#125;()</span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line">&#125;</span><br><span class="line">_ = double(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// "double(4) = 8"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>被延迟执行的函数甚至可以修改函数返回给调用者的返回值：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">    <span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// "12"</span></span><br></pre></td></tr></table></figure><h3 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h3><p>数组访问越界、空指针引用等运行时出现的错误会引起panic异常。一般而言，panic异常发生的时候，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。</p><p>在健壮的程序中，任何可以预料到的错误都应该被优雅的地处理，最好的处理方式就是Go的错误机制，应该为了尽量避免程序的崩溃而少用panic。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的参数 p 成为方法的接收器。Go语言中，不会像其他语言那样用this或者self作为接收器，可以任意选择接收器的名字。建议保持其方法间传递时候的一致性和简短性，建议可以使用类型的第一个字母，如上所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q)) <span class="comment">// "5", function call</span></span><br><span class="line">fmt.Println(p.Distance(q))  <span class="comment">// "5", method call“选择器”</span></span><br></pre></td></tr></table></figure><p>不同的Distance调用指向不同类型中的Distance方法。定义Path类型表示线段的集合，给其也定义一个Distance方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Path is a journey connecting the points with straight lines.</span></span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"><span class="comment">// Distance returns the distance traveled along the path.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span> <span class="title">Distance</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += path[i<span class="number">-1</span>].Distance(path[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Path是一个命名的slice类型，而非Point这种struct类型，但依然可以为其定义方法。和其他语言不同，在Go语言中，我们为一些简单的数值、字符串、slice、map来定义一些附加行为十分方便。我们可以给同一个包内的任意命名累习惯定义方法，只要<strong>这个命名类型的底层类型</strong>（如Path这种命名类型中的[]Point这个slice的底层类型）<strong>不是指针或者interface</strong>。在两个对Distance名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。</p><p>由于一个给定的类型内部的方法有唯一的方法名，不同类型之间可以有同样的方法名，所以没有必要在方法名之前加类型名来消除歧义，因此方法名相比较函数名的好处是可以尽可能简短，这在包外调用的时候将具有优势。</p><h3 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h3><p>在每一个合法的方法调用表达式中，下面三种情况里的任意一种情况都是可以的：</p><p>要么接收器的实际参数和其形式参数是相同的类型，比如两者都是类型T或者都是类型<code>*T</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.Distance(q) <span class="comment">//  Point</span></span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)         <span class="comment">// *Point</span></span><br></pre></td></tr></table></figure><p>或者接收器实参是类型T，但接收器形参是类型<code>*T</code>，这种情况下编译器会隐式地为我们取变量的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ScaleBy(<span class="number">2</span>) <span class="comment">// implicit (&amp;p)</span></span><br></pre></td></tr></table></figure><p>或者接收器实参是类型<code>*T</code>，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pptr.Distance(q) <span class="comment">// implicit (*pptr)</span></span><br></pre></td></tr></table></figure><ul><li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换</li><li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。</li></ul><h4 id="Nil也是一个合法的接收器类型"><a href="#Nil也是一个合法的接收器类型" class="headerlink" title="Nil也是一个合法的接收器类型"></a>Nil也是一个合法的接收器类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntList is a linked list of integers.</span></span><br><span class="line"><span class="comment">// A nil *IntList represents the empty list.</span></span><br><span class="line"><span class="keyword">type</span> IntList <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="keyword">int</span></span><br><span class="line">    Tail  *IntList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sum returns the sum of the list elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *IntList)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.Value + list.Tail.Sum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nil.Sum()无法通过编译，应该写成Value(nil).Sum()。</li></ul><h3 id="通过嵌入结构体来扩展类型"><a href="#通过嵌入结构体来扩展类型" class="headerlink" title="通过嵌入结构体来扩展类型"></a>通过嵌入结构体来扩展类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法只能在命名类型（像Point）或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名struct类型来定义方法也有了手段。</p><p>下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量和它所操作的cache：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex <span class="comment">// guards mapping</span></span><br><span class="line">    mapping = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    v := mapping[key]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给新的变量起了一个更具表达性的名字：cache。因为sync.Mutex字段也被嵌入到了这个struct里，其Lock和Unlock方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。</p><h2 id="推荐阅读-amp-资料"><a href="#推荐阅读-amp-资料" class="headerlink" title="推荐阅读 &amp; 资料"></a>推荐阅读 &amp; 资料</h2><p><a href="http://books.studygolang.com/gopl-zh/ch5/ch5-07.html" target="_blank" rel="noopener">《Go圣经》</a></p><p><a href="https://chai2010.gitbooks.io/advanced-go-programming-book/content/ch1-basic/readme.html" target="_blank" rel="noopener">《Go语言高级编程》</a></p>]]></content>
    
    <summary type="html">
    
      Golang学习，仅作笔记，不成体系
    
    </summary>
    
      <category term="Tech" scheme="http://bingcs.com/categories/Tech/"/>
    
    
      <category term="Golang" scheme="http://bingcs.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Social Media Analysis (4)</title>
    <link href="http://bingcs.com/2021/04/21/socialmedia-a4/"/>
    <id>http://bingcs.com/2021/04/21/socialmedia-a4/</id>
    <published>2021-04-21T14:31:06.000Z</published>
    <updated>2021-04-24T03:53:59.728Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-Sentiment-Analysis"><a href="#1-Sentiment-Analysis" class="headerlink" title="1. Sentiment Analysis"></a>1. Sentiment Analysis</h2><p>I obtained in Project One is 0.89 . It means that basiclly, comments given to me or I give to others are positive. </p><h2 id="2-Social-Network-Analysis"><a href="#2-Social-Network-Analysis" class="headerlink" title="2. Social Network Analysis"></a>2. Social Network Analysis</h2><ol><li>My in-degree is 8, which means that there are 8 people that have ever left a comment in my blogs. I think the number is not as many as I thought. Maybe I should have more interactions with my classmates and the in-degree might be more. </li><li>My out-degree is 11, which means that I gave comments to 11 classmates. That’s more than my in-degree. But I believe if more classmates I have given comments, maybe the in-degree will be more. </li><li>My closeness centrality is 0.44. The value is between 0 and 1. The more closeness centrality is, the more interaction with classmates. The more out-degree is, the more closenesss centrality will be. (Not exactly proportional)</li><li>My shortest-path betweenness is 0.0137. It means the number of shortest-path that go through a point, which shows the importance of a point. 0.01 maybe a little bit small.</li></ol><h2 id="3-Overall-Course-Reflection"><a href="#3-Overall-Course-Reflection" class="headerlink" title="3. Overall Course Reflection"></a>3. Overall Course Reflection</h2><p>In this course, I have learn some skills to do the social media analysis. And it is the first time of mine to see our behaviors in such a way, using some programming methods. </p><p>Also, I shared with others my understandings of some concepts like “Mutual Information”, or the relationship between emotions and dynamic free energy. I also gave some examples which impress some of my classmates. </p><p>I feel that using the technical or analytics way to think about our social behaviors could make us more positive in the social interaction. The more people you give comments to, the more comments you will get.</p><p>After this course, I think I will be more willing to share my comments or interact with people in the future life. And also I will keep using these methods to analyze the behavior of people. This course really took me in to the trip to social analysis world.</p>]]></content>
    
    <summary type="html">
    
      Course Assignment
    
    </summary>
    
      <category term="CUHK" scheme="http://bingcs.com/categories/CUHK/"/>
    
    
  </entry>
  
  <entry>
    <title>Social Media Analysis (3)</title>
    <link href="http://bingcs.com/2021/03/06/socialmedia-a3/"/>
    <id>http://bingcs.com/2021/03/06/socialmedia-a3/</id>
    <published>2021-03-06T14:31:06.000Z</published>
    <updated>2021-03-07T03:52:04.714Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-Computational-Calculation"><a href="#1-Computational-Calculation" class="headerlink" title="1. Computational / Calculation"></a>1. Computational / Calculation</h2><h3 id="1-H-X"><a href="#1-H-X" class="headerlink" title="1) H(X)"></a>1) H(X)</h3><p>My student ID is 1155151103 so the 8 outcomes of Y is {aaeeaeaa}. The student ID of my partner is 1155148799 so the 8 outcomes of X is {aaeeadhg}</p><table><thead><tr><th>Outcomes</th><th>1st</th><th>2nd</th><th>3rd</th><th>4th</th><th>5th</th><th>6th</th><th>7th</th><th>8th</th></tr></thead><tbody><tr><td>Y =</td><td>a</td><td>a</td><td>e</td><td>e</td><td>a</td><td>e</td><td>a</td><td>a</td></tr><tr><td>X =</td><td>a</td><td>a</td><td>e</td><td>e</td><td>a</td><td>d</td><td>h</td><td>g</td></tr></tbody></table><p>In the 8 outcomes of Y, </p><p>P(a) = 5/8, P(e) = 3/8</p><p>In the 8 outcomes of X,</p><p>P(a) = 3/8, P(d) = 1/8, P(e) = 2/8 = 1/4, P(h) = 1/8,  P(g) = 1/8</p><p>So the H(X) can be calculated out:</p><p><strong>H(X)</strong> = -(0.375*log2(0.375) + 0.125*log2(0.125)*3 + 0.25*log2(0.25))</p><p>= -(-0.531 -1.125 -0.5) </p><p><strong>= 2.156</strong> </p><h3 id="2-Joint-probability-distribution-matrix"><a href="#2-Joint-probability-distribution-matrix" class="headerlink" title="2) Joint probability distribution matrix"></a>2) Joint probability distribution matrix</h3><table><thead><tr><th align="center">PXY(x,y)</th><th align="center">a</th><th align="center">e</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">15/64</td><td align="center">9/64</td></tr><tr><td align="center">d</td><td align="center">5/64</td><td align="center">3/64</td></tr><tr><td align="center">e</td><td align="center">5/32</td><td align="center">3/32</td></tr><tr><td align="center">h</td><td align="center">5/64</td><td align="center">3/64</td></tr><tr><td align="center">g</td><td align="center">5/64</td><td align="center">3/64</td></tr></tbody></table><h3 id="3-H-X-Y-and-I-X-Y"><a href="#3-H-X-Y-and-I-X-Y" class="headerlink" title="3) H(X|Y) and I(X,Y)"></a>3) H(X|Y) and I(X,Y)</h3><p>Since we don’t know our partner’s student ID at first, or we don’t know waht is the observerd result of our partner’s, these two distribution X and Y could be seemed as independent with each other. So <strong>P(X|Y) = P(X).</strong> So <strong>H(X|Y) = H(X) = 2.156</strong> (we have already calculated out in 1) ). </p><p>And with the formula <strong>H(X) = H(X|Y) + I(X,Y)</strong>, we know the value of H(X) is the sum of the value of mutual information I(X,Y) and H(X|Y). So in this case we can easily get the value of <strong>I(X,Y) =</strong> H(X) - H(X|Y) = 2.156 - 2.156 </p><p><strong>= 0</strong></p><h2 id="2-Mutual-Information"><a href="#2-Mutual-Information" class="headerlink" title="2. Mutual Information"></a>2. Mutual Information</h2><p>Mutual information measures the degree of interdependence between random variables. Let’s take the things in our daily life as example. </p><h3 id="An-example-Sunset-glow"><a href="#An-example-Sunset-glow" class="headerlink" title="An example: Sunset glow"></a>An example: Sunset glow</h3><p>We know the Chinese saying that “朝霞不出门，晚霞行千里”, which means that when you see the morning glow, you’d better not go out this day (due to the high possibility of raining) and if you see the sunset glow, you might go out for a thousand miles of walk (for the high possibility of sunny the next day). </p><p>Let’s apply the concept of mutual information to this example. Assume that “it is rainy tomorrow” is a random event X, and “there is sunset glow tonight” is a random event Y. So when we don’t have any idea of whether “sunset glow tonight”, the uncertainty of “rainy tomorrow” is <strong>H(X)</strong>. And if we already know that “sunset glow tonight”, the uncertainty of “rainy tomorrow” is <strong>H(X|Y)</strong>. And the <strong>mutual information I(X,Y)</strong> will be the difference between H(X) and H(X|Y), which measures the reduction in uncertainty of a random variable X due to another random variable Y. It shows that when knowing “sunset glow tonight”, to what extent we will feel less uncertain about “rainy tomorrow”. I am not going to quantilization the value of I(X,Y) here because it could be 0 or more than 0, which are both possible in different case. </p>]]></content>
    
    <summary type="html">
    
      Course Assignment
    
    </summary>
    
      <category term="CUHK" scheme="http://bingcs.com/categories/CUHK/"/>
    
    
  </entry>
  
  <entry>
    <title>Social Media Analysis (2)</title>
    <link href="http://bingcs.com/2021/02/19/socialmedia-a2/"/>
    <id>http://bingcs.com/2021/02/19/socialmedia-a2/</id>
    <published>2021-02-19T09:04:13.000Z</published>
    <updated>2021-02-21T11:46:27.341Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-Divergence"><a href="#1-Divergence" class="headerlink" title="1. Divergence"></a>1. Divergence</h2><ul><li><strong>Description</strong></li></ul><p>Let Ni for i = 1 to 10 be the i-th digit of a valid CUHK student ID, and N be the sum of these 10 digits. Let q(x) be the approximated probability mass function where q(i) = Ni/N for i = 1 to 10 is obtained from your own student ID. Furthermore, let p(x) be the true probability mass function obtained by replacing your student ID with that of your partner’s. Calculate: <strong>(1) forward divergence; (2) reverse divergence.</strong></p><ul><li><strong>Solution</strong></li></ul><p>My student ID is 1155151103 but in order to prevent an denominator from being 0, I would turn the digit 0 to 2. So the ID will become 1155151123. The sum of each digit is 25. The student ID of my partner is 1155148799 so the sum of each digit is 50. </p><p>So pi for i = 1 to 10 are: 0.04, 0.04, 0.2, 0.2, 0.04, 0.2, 0.04, 0.04, 0.08, 0.12. </p><p>And qi for i = 1 to 10 are: 0.02, 0.02, 0.1, 0.1, 0.02, 0.08, 0.16, 0.14, 0.18, 0.18.</p><p>So the <strong>forward divergence D(p||q)</strong> is: </p><p>0.04*log2(0.04/0.02) + 0.04*log2(0.04/0.02) + 0.2*log2(0.2/0.1) + 0.2*log2(0.2/0.1) + 0.04*log2(0.04/0.02) + 0.2*log2(0.2/0.08) + 0.04*log2(0.04/0.16) + 0.04*log2(0.04/0.14) + 0.08*log2(0.08/0.18) + 0.12*log2(0.12/0.18) </p><p>= 0.04+0.04+0.2+0.2+0.04+0.26+0.05-0.07-0.09-0.7 </p><p>= <strong>-0.03</strong></p><p>And the <strong>reverse divergence D(q||p)</strong> is: </p><p>0.02*log2(0.02/0.04) + 0.02*log2(0.02/0.04) + 0.1*log2(0.1/0.2) + 0.1*log2(0.1/0.2) + 0.02*log2(0.02/0.04) + 0.08*log2(0.08/0.2) + 0.16*log2(0.16/0.04) + 0.14*log2(0.14/0.04) + 0.18*log2(0.18/0.08) + 0.18*log2(0.18/0.12) </p><p>= -0.02-0.02-0.1-0.1-0.1-0.1+0.32+0.25+0.21+0.1 </p><p>= <strong>0.44</strong></p><h2 id="2-Suprise"><a href="#2-Suprise" class="headerlink" title="2. Suprise"></a>2. Suprise</h2><p>Since the information content  of the individual event or the “surprise” of the event is calculated by:</p><center>I(E) = -log(P(E))</center><p>For the observed event x = 10, from last question we know the probability that this event happens is 0.18. So the surprise of it is: </p><p>-log2(0.18) = -(-2.47) = <strong>2.47</strong></p><h2 id="3-Free-Energy"><a href="#3-Free-Energy" class="headerlink" title="3. Free Energy"></a>3. Free Energy</h2><p>From last two questions we have already got the reverse divergence (=0.1) and surprise (=2.47) of event No.10. Using the formula:</p><center>Free Energy = Reverse Divergence + Surprise</center><p>we could easily get Free Energy (F) = 0.1 + 2.47 </p><p><strong>= 2.57</strong></p><h2 id="4-Relationship-between-emotions-and-dynamic-free-energy"><a href="#4-Relationship-between-emotions-and-dynamic-free-energy" class="headerlink" title="4. Relationship between emotions and dynamic free energy"></a>4. Relationship between emotions and dynamic free energy</h2><blockquote><p>According to Joffily &amp; Coricelli (2013), how do the emotions “happiness”, “unhappiness”, “hope”, and “fear” relate to the dynamic free energy F(t)?</p></blockquote><p>According to Joffily &amp; Coricelli’s research, emotions are explained by the change of free-energy. And the first time-derivative Fi’(t) and second time-derivative Fi’’(t) of free-energy can be understood as the <strong>velocity</strong> and <strong>acceleration</strong> of free-energy Fi(t) at time t. Our emotions are changing all the time and the dynamics of free-energy show the temporal dependency within the emotion forms. We know that <strong>free-energy is decreasing when the real fact comes closer to our expectation</strong>. </p><h3 id="An-example-waitng-for-the-bus"><a href="#An-example-waitng-for-the-bus" class="headerlink" title="An example: waitng for the bus"></a>An example: waitng for the bus</h3><p>Take four basic emotions, happy, unhappy, hopes, fears, as example. Assume that you are David and you are waiting for bus No.1. You are in the emotion of “<strong>hopes</strong>“ when you want the bus No.1 to come (free-energy is decreasing, F’(t)&lt;0) and you are not sure whether it will come (decreasing faster and faster, F’’(t)&lt;0). And when the bus No.1 really comes, you are “<strong>happy</strong>“ (free-energy is still decreasing, F’(t)&lt;0, but slower because the event is factive, F’’(t)&gt;0). And equivalently, when hopes bus No.1 to come, for the event “here comes bus No.2”, you are in the emotion of “fears” because it is far away from your expectation. So when “<strong>fears</strong>“, free-energy is increasing (F’(t)&gt;0) and because of the uncertaincy (epistemic), this increasing is faster and faster(F’’(t)&gt;0). And when the event “here comes the bus No.2” happen, this fact is far away from your expectation, free-enegy is increasing (F’(t)&gt;0) but slower (because factive, F’’(t)&lt;0). Then youe emotion is “<strong>unhappy</strong>“. </p><p>From above, you can also see that when the bus has not come (epistemic event), your emotion could be concurrently in the status of “fears”(for bus No.2) or “hopes”(for bus No.1). It shows that it is common that different emotions can occur at the same time.</p><p>This relationship are shown in the table and figure below. </p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-02-21-102249.png" alt="image-20210221172520150"></p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-02-21-102242.png" alt="image-20210221175815162"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Joffily M, Coricelli G (2013) Emotional Valence and the Free-Energy Principle. PLoS Comput Biol 9(6): e1003094.</p>]]></content>
    
    <summary type="html">
    
      Course Assignment
    
    </summary>
    
      <category term="CUHK" scheme="http://bingcs.com/categories/CUHK/"/>
    
    
  </entry>
  
  <entry>
    <title>Social Media Analysis (1)</title>
    <link href="http://bingcs.com/2021/01/26/socialmedia-a1/"/>
    <id>http://bingcs.com/2021/01/26/socialmedia-a1/</id>
    <published>2021-01-26T08:14:51.000Z</published>
    <updated>2021-01-31T03:23:21.018Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-Shannon-Entropy"><a href="#1-Shannon-Entropy" class="headerlink" title="1. Shannon Entropy"></a>1. Shannon Entropy</h2><ul><li><strong>Description</strong></li></ul><p>Let there be a system having 10 discrete energy levels, from 1 to 10. Let N be the sum of the digits of your student ID, e.g., if your SID = 1155012345, then N = 27. Let Pi = Ni/N for i=1 to 10 be the probability that the system is at an energy level i. </p><p>Calculate the <strong>Shannon entropy</strong> of the system.</p><ul><li><strong>Solution</strong></li></ul><p>My student ID is 1155151103 so N = 23. </p><p>So Ni (for i = 1 to 10) is {1/23, 1/23, 5/23, 5/23, 1/23, 5/23, 1/23, 1/23, 0, 3/23}. And We calculate Shannon Entropy using the formulation shown below. </p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2021-01-30-064608.png" alt="image-20210129113456540"></p><p>We can first calculate the information content of each energy level of the system. </p><p>log2(1/23) = -4.52</p><p>log2(3/23) = -2.93</p><p>log2(5/23) = -2.20</p><p>So the calculation result of H(X) is: </p><p>H(X) = -(1/23*(-4.52) + 1/23*(-4.52) + 5/23*(-2.20) +  5/23*(-2.20) + 1/23*(-4.52) + 5/23*(-2.20) + 1/23*(-4.52) + 1/23*(-4.52) + 0 + 3/23*(-2.93)) = 2.80</p><p>So the Shannon entropy of this system is 2.80.</p><h2 id="2-What-is-Friston’s-Free-Energy-Principle-FEP"><a href="#2-What-is-Friston’s-Free-Energy-Principle-FEP" class="headerlink" title="2. What is Friston’s Free Energy Principle (FEP)?"></a>2. What is Friston’s Free Energy Principle (FEP)?</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>In a word, Friston’s Free Energy Priciple (FEP) is used to describe that every self-organizing system in equilibrium tends to be in a state of minimal free energy. </p><p>In Friston’s assumption, FEP could be applied to the whole world, including not only the perception, motion control or memory of our brains or our body, but also the biological evolution or the changes in the natural environment. </p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><h4 id="formula"><a href="#formula" class="headerlink" title="formula"></a>formula</h4><p><strong>Free energy = Internal energy - Entropy</strong></p><p>–&gt; Error  = real case - prediction</p><p>In this formulation, internal energy refers to energy of sensor data for example that received through perception. And entropy is “calculated” by a probably model which is constructed by our brain (the agent) to describe the sensor data. </p><p>To make it easy, just see internal energy as “real case”, entropy as “prediction” and free energy as “prediction error”. The main goal of our brain perceiving the circumstances is to predict the changes of the circumstances. If our brain could predict it correctly, we know that it result in a smallest prediction error. </p><p>To get the minimal free energy, mathematically, one way is to increase the entropy (change our probably model to get better prediction result), another is to decrease internal energy (change the circumstances or choose other real case to make it more close to our prediction).</p><h4 id="Markov-blanket"><a href="#Markov-blanket" class="headerlink" title="Markov blanket"></a>Markov blanket</h4><p>Markov blanket is a key part of FEP. By restricting the interaction between inside and outside of the “blanket”, it proctect the internal state from the influence of the enviroment and prevent the external state from being changed by the agent (e.g. our brain). It is like a “cell membrane” or those diaphragm in our body to seperate our organs. </p><h2 id="3-How-can-FEP-be-applied-to-explain-the-information-dynamics-in-social-media"><a href="#3-How-can-FEP-be-applied-to-explain-the-information-dynamics-in-social-media" class="headerlink" title="3. How can FEP be applied to explain the information dynamics in social media?"></a>3. How can FEP be applied to explain the information dynamics in social media?</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>From my point of view, the procedure of minimizing the free energy is quite similar to people finding the most satisfying social enviroment in this digital world to minimize the difference between the real world and expectation. </p><p>See from the formula of FEP, we know that the keys to the optimal social enviroment are either (1) changing the social environment we located or (2) modifying our prediction or expectation to fit the environment. Both of the methods are related to information dynamics. </p><h3 id="Two-Examples"><a href="#Two-Examples" class="headerlink" title="Two Examples"></a>Two Examples</h3><p>Take recommender system as the example for the former one (environment changing), we are using social media applications like TikTok and we may found that these apps know us a lot. It seems like they always know what kind of things we want to see and recommend those interesting videos to us. This is because the recommendation systems under these apps take the information of our or even our friends’ watching history as the input and train the specifc recommendation model for us so that the more we use these apps, the better they know us. This procedure shows that the information of our behaviors influent the social enviroment, or call it the internal state influent the external state. </p><p>And another example for the latter one (expectation modifying) is that people are getting more and more adaptable to the developing digital world. From web application in 3G to short video in 4G and then AR/VR in 5G, or the social media platform developing from Renren to Weibo and then Weibo, TikTok, the digital world that people exist in are changing constantly. People get information through sensory perception. In order not to be outdated we have to get ourselves used to those social applications that more and more people start to use or we choose the apps that people around us most lukely to use. This shows that the information from outside environment greatly influent the agent ourselves, or call it the external state influent the internal state. </p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://en.wikipedia.org/wiki/Free_energy_principle" target="_blank" rel="noopener">[Wikipedia] Free energy principle</a></li><li><a href="https://en.wikipedia.org/wiki/Markov_blanket" target="_blank" rel="noopener">[Wikipedia] Markov Blanket</a></li><li><a href="https://zhuanlan.zhihu.com/p/55839967" target="_blank" rel="noopener">[知乎] 自由能最小原理说的是什么？</a></li></ul>]]></content>
    
    <summary type="html">
    
      Course Assignment
    
    </summary>
    
      <category term="CUHK" scheme="http://bingcs.com/categories/CUHK/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac终端改造计划</title>
    <link href="http://bingcs.com/2020/12/21/macTerminalRebuild/"/>
    <id>http://bingcs.com/2020/12/21/macTerminalRebuild/</id>
    <published>2020-12-21T02:21:28.000Z</published>
    <updated>2021-02-10T03:32:03.226Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Mac终端(Terminal)凭借Unix特性让用户爱不释手，但作为程序员们频繁使用的软件，其默认界面的文字阅读常令人感到吃力。我将借助oh-my-zsh对其进行界面上的美化，让Terminal更加美观易读。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-12-21-023914.png" alt="未改造之前的Terminal"></p><center>Figure 1. 原本的Terminal界面</center><h2 id="0-准备：安装Homebrew"><a href="#0-准备：安装Homebrew" class="headerlink" title="0. 准备：安装Homebrew"></a>0. 准备：安装Homebrew</h2><p>后续的部分插件安装需要用到homebrew，所以可以提前安装。</p><p><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p><p>如果你的macOS版本早于Catalina，你需要手动安装zsh：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 zsh</span></span><br><span class="line">brew install zsh</span><br><span class="line"><span class="comment"># 设置zsh为你的默认shell</span></span><br><span class="line">chsh -s /usr/<span class="built_in">local</span>/bin/zsh</span><br></pre></td></tr></table></figure><h2 id="1-配置Mac终端主题"><a href="#1-配置Mac终端主题" class="headerlink" title="1. 配置Mac终端主题"></a>1. 配置Mac终端主题</h2><ol><li>在 <a href="https://github.com/lysyi3m/macos-terminal-themes" target="_blank" rel="noopener">OSX主题的项目主页</a> 里面选择自己喜欢的主题；</li><li>把项目Clone或者Download下来；</li><li>在 <code>themes/</code> 文件夹下，双击相应的*.terminal 文件。一个对应主题的终端窗口将会弹出；</li><li>将当前主题设置为默认：菜单里找到 <em>Shell -&gt; Use Settings as Default</em> 或 <em>Shell -&gt; 将设置用作默认设置</em> 。</li></ol><h2 id="2-安装-oh-my-zsh"><a href="#2-安装-oh-my-zsh" class="headerlink" title="2. 安装 oh-my-zsh"></a>2. 安装 oh-my-zsh</h2><p>参考 <a href="https://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh 主页</a>。Oh My Zsh 是一个令人愉快的、开源的、社区驱动的管理zsh配置的框架，安装十分简单，在Mac终端下输入如下代码即可。</p><p><code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p><h2 id="3-安装-oh-my-zsh-主题"><a href="#3-安装-oh-my-zsh-主题" class="headerlink" title="3. 安装 oh-my-zsh 主题"></a>3. 安装 oh-my-zsh 主题</h2><p>如果不想鼓捣第三方主题，oh-my-zsh内置的主题其实也完全足够。只需要：</p><ol><li>在<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">内置主题列表</a>寻找你想要的主题；</li><li>在<code>~/.zshrc</code>配置文件里设置<code>ZSH_THEME</code>为你想要的主题名称；如果你不想使用任何内置主题，也可以把这个字段设置为空：<code>ZSH_THEME=&quot;&quot;</code></li><li>激活设置<code>source ~/.zshrc</code></li></ol><p>当然，如果想要安装第三方主题，也可以在 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">这里</a> 查看。</p><h2 id="4-安装oh-my-zsh插件"><a href="#4-安装oh-my-zsh插件" class="headerlink" title="4. 安装oh-my-zsh插件"></a>4. 安装oh-my-zsh插件</h2><p>Oh-my-zsh提供了丰富的插件，你可以通过查看Github上地 <a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins" target="_blank" rel="noopener">plugins目录</a>或者 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins" target="_blank" rel="noopener">wiki</a>来获知哪些插件是可用的。除了许多自带的插件可以直接在~/.zshrc 文件的 plugins字段按如下方式使用，也可以便捷地安装其他的插件。下面列举5个插件，更多地插件可以自行寻找。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.zshrc:</span></span><br><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote><p>自带插件。可以使用缩写命令, 比如 <code>gaa</code> -&gt; <code>git add --all</code>, 通过<code>alias | grep git</code>查看所有支持缩写命令。直接按上面的方式加入plugins字段。</p></blockquote><h3 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h3><blockquote><p>自带插件。不用再使用复杂的<code>tar</code>来解压。直接按上面的方式加入plugins字段。</p></blockquote><h3 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h3><blockquote><p>自带插件。可以使用sublime text打开文件/文件夹，用 <code>st</code> 指令直接打开sublime text (前提是已经安装)，用<code>st + 文件/文件夹</code> 可以用sublime打开指定文件夹 。直接按上面的方式加入plugins字段。</p></blockquote><h3 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h3><blockquote><p>非自带插件。使用<code>j</code>命令直接快速进入某个目录, 比如 <code>j Downloads</code> -&gt; <code>cd ~/Downloads</code>。</p></blockquote><p>用 <code>brew install autojump</code> 安装之后，按照提示在<code>~/.zshrc</code>配置文件添加:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -f /usr/<span class="built_in">local</span>/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/<span class="built_in">local</span>/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure><h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h3><blockquote><p>非自带插件。命令高亮，让命令五彩缤纷。</p></blockquote><p>用  <code>brew install zsh-syntax-highlighting</code> 完成安装。按照安装完成后的提示，在~/.zshrc文件中进行相应的配置。</p><h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h3><blockquote><p>非自带插件。输入时按右方向键→自动补全命令。</p></blockquote><p>用 <code>brew install zsh-autosuggestions</code> 完成安装。按照安装完成后的提示，在~/.zshrc文件中进行相应的配置。</p><h2 id="5-完成"><a href="#5-完成" class="headerlink" title="5. 完成"></a>5. 完成</h2><p>至此， 你应该可以拥有一个美观易用的terminal了。开始coding吧！</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-12-21-070158.png" alt="image-20201221150157035"></p><center>Figure 2. 配置之后的Terminal界面</center><h2 id="Optional-zsh安装后的conda使用：报错与解决"><a href="#Optional-zsh安装后的conda使用：报错与解决" class="headerlink" title="(Optional) zsh安装后的conda使用：报错与解决"></a>(Optional) zsh安装后的conda使用：报错与解决</h2><p>在安装完zsh，开始要使用原本环境中conda相关指令的时候出现错误，以下是错误内容和相应的解决方案。</p><ol><li><p><code>zsh：command not find:conda</code></p><ul><li><p>首先检查是否安装了conda。在anaconda安装的文件夹下的bin文件夹查看是否有conda指令，没有的话就是尚未安装。</p></li><li><p>如果已经安装了conda，但是仍然报这个错，应该是因为环境变量配置文件没有更新。对于zsh来说，配置文件是 ~/.zshrc。</p><blockquote><p>简单来说.zshrc是linux文件夹的一个配置文件，这个文件主要保存个人的一些个性化设置，比如命名别名、路径等。</p></blockquote></li><li><p><code>vi ~/.zshrc</code> 打开配置文件。</p></li><li><p>在文件末尾加入一行<code>export PATH=/path/to/anaconda/bin:$PATH</code> 。注意这里的路径需要改成自己电脑上的anaconda的路径。比如我的电脑上装的是miniconda3，路径是 /Users/bing/miniconda3/，那么这一句就应该是<code>export PATH=/Users/bing/miniconda3/bin:$PATH</code>。添加完成后保存退出。</p></li><li><p><code>source ~/.zshrc</code> 使配置文件的修改立即生效。</p></li><li><p>再次查看conda指令，输入<code>conda --version</code>，如果可以正常显示版本号，说明问题已经解决。</p></li></ul></li><li><p><code>CommandNotFoundError: Your shell has not been properly configured to use &#39;conda activate&#39;.</code>  </p><p><strong>解决</strong>：用<code>source activate</code> 重新激活一下activate，这时候当前环境会变更到(base)，说明activate指令可以正常运行了。</p></li></ol><h2 id="Optional-zsh自定义快捷指令"><a href="#Optional-zsh自定义快捷指令" class="headerlink" title="(Optional) zsh自定义快捷指令"></a>(Optional) zsh自定义快捷指令</h2><p>平时使用terminal的时候，我们输入很长的指令往往会感到繁琐头疼。我们可以通过修改zshrc文件来设置快捷指令。</p><p>比如想要用安装的Typora软件来打开某个Markdown文件，我们需要命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -a "Typora" filename.md</span><br></pre></td></tr></table></figure><p>前摇过长，不能忍。</p><p>要实现类似 <code>st filename.md</code> 这种用Sublime Text快捷打开文件的操作，我们需要向~/.zshrc文件添加一行<code>alias</code>指令替换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把 tp 指定为 open -a <span class="string">"Typora"</span>，并添加到 ~/.zshrc 文件末尾</span></span><br><span class="line">echo "alias tp="open -a "Typora" " " &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行立即生效</span></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>然后试试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp filename.md</span><br></pre></td></tr></table></figure><p>可以发现已经可以快捷打开某文件。同理可以自行设置其他的快捷指令。:-)</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh - 官网</a></li><li><a href="https://github.com/ohmyzsh" target="_blank" rel="noopener">Oh My Zsh - Github主页</a></li><li><a href="https://tonyxu.io/zh/posts/2018/ultimate-way-to-beautify-mac-terminal-and-recommendations-for-plugins/" target="_blank" rel="noopener">程序员的Mac终端(oh-my-zsh)终极美化及必备插件推荐 | Tony Xu 博客</a></li></ol>]]></content>
    
    <summary type="html">
    
      oh-my-zsh
    
    </summary>
    
      <category term="Tech" scheme="http://bingcs.com/categories/Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>IERG4160 Image and Video Processing</title>
    <link href="http://bingcs.com/2020/12/02/IERG4160/"/>
    <id>http://bingcs.com/2020/12/02/IERG4160/</id>
    <published>2020-12-02T08:22:54.000Z</published>
    <updated>2021-01-26T08:17:03.495Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Lecture-07-Object-Recogonition"><a href="#Lecture-07-Object-Recogonition" class="headerlink" title="Lecture 07 Object Recogonition"></a>Lecture 07 Object Recogonition</h2><ul><li>What is Object Recogonition</li><li>Pipeline: image –&gt; feature –(classifier)–&gt; class label</li><li>feature representation<ul><li>Bag of words</li><li>dictionary &lt;– K-means</li></ul></li><li>local descriptor &lt;– HOG</li><li>Spatial Pyramid / Part-based models (basic ideas)</li><li>Classifier<ul><li>K-means neighbor</li></ul></li></ul><h2 id="Lecture-08-Linear-Classifier"><a href="#Lecture-08-Linear-Classifier" class="headerlink" title="Lecture 08 Linear Classifier"></a>Lecture 08 Linear Classifier</h2><ul><li>Binary Classificatoin</li><li>Linear Classifier    f(x)=sign(wT+b)</li><li>Perceptron Algorithm   w&lt;–w+a<em>Yi</em>Xi (when misclassified)<ul><li>(linearly separable)</li></ul></li><li>Support Vector Machine &lt;– maximize the margin</li><li>Slack Variable &lt;– trade off</li></ul><h2 id="Lecture-09-Multi-class-Classification"><a href="#Lecture-09-Multi-class-Classification" class="headerlink" title="Lecture 09 Multi-class Classification"></a>Lecture 09 Multi-class Classification</h2><ul><li>Basic concept</li><li>Combine binary classifiers<ul><li>One-vs-all  –  k</li><li>All-vs-all  –  k(k-1)/2</li><li>minimum # classifiers  – log(2)k</li></ul></li></ul><h2 id="Lecture-10-Deep-Learning"><a href="#Lecture-10-Deep-Learning" class="headerlink" title="Lecture 10 Deep Learning"></a>Lecture 10 Deep Learning</h2><ul><li>Deep: multi-level conputation for feature</li><li>Learning: end to end</li><li>Simpified formulation</li></ul><h2 id="Lecture-11-CNN-Convolutional-Neural-Network"><a href="#Lecture-11-CNN-Convolutional-Neural-Network" class="headerlink" title="Lecture 11 CNN (Convolutional Neural Network)"></a>Lecture 11 CNN (Convolutional Neural Network)</h2><ul><li>convolutional layer<ul><li>3D kernel –&gt; single mask (h·w·n_i)</li><li>multiple kernel –&gt; (h·w·n_i·n_o)</li><li>Together –&gt; convolutional layer</li></ul></li><li>activation</li><li>Pooling</li></ul><h2 id="Lecture-10b-Training-Process"><a href="#Lecture-10b-Training-Process" class="headerlink" title="Lecture 10b Training Process"></a>Lecture 10b Training Process</h2><ul><li>SGD: </li><li>back-propagation</li></ul><h2 id="Lecture-12-Object-Detection"><a href="#Lecture-12-Object-Detection" class="headerlink" title="Lecture 12 Object Detection"></a>Lecture 12 Object Detection</h2><ul><li><p>What is Object Detection </p><ul><li>bounding boxes</li></ul></li><li><p>R-CNN / Fast R-CNN / Faster R-CNN (Basic idea)</p><ul><li>Share computation –&gt; improve efficiency</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      CUHK Postgraduate Course
    
    </summary>
    
      <category term="CUHK" scheme="http://bingcs.com/categories/CUHK/"/>
    
    
  </entry>
  
  <entry>
    <title>学习笔记-《清华大学C++程序设计》</title>
    <link href="http://bingcs.com/2020/09/21/Notes-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://bingcs.com/2020/09/21/Notes-清华大学C-程序设计/</id>
    <published>2020-09-21T03:17:06.000Z</published>
    <updated>2021-01-01T04:13:44.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-类与对象"><a href="#第四章-类与对象" class="headerlink" title="第四章 类与对象"></a>第四章 类与对象</h2><h2 id="第五章-数据的共享与保护"><a href="#第五章-数据的共享与保护" class="headerlink" title="第五章 数据的共享与保护"></a>第五章 数据的共享与保护</h2><ul><li>变量和对象定义在不同的位置, 其作用域、可见性、生存期都不同。</li><li>友元：对一些类外的函数、其他的类给予授权，使之可以访问本类的私有成员。</li><li>如何保障安全性？通过const关键字，限制对共享类型的修改</li></ul><h3 id="1-标识符的作用域与可见性"><a href="#1-标识符的作用域与可见性" class="headerlink" title="1. 标识符的作用域与可见性"></a>1. 标识符的作用域与可见性</h3><h4 id="1-1-作用域分类"><a href="#1-1-作用域分类" class="headerlink" title="1.1 作用域分类"></a>1.1 作用域分类</h4><ul><li>函数原型作用域：函数原型中的参数，形参表中的()括号之内<ul><li>函数声明中: double func(double a);</li></ul></li><li>局部作用域（块作用域）：函数的形参、在块中声明的标识符，作用域自声明处起，限于块中</li><li>类作用域：类的成员具有类作用域，范围包括类体和成员函数体<ul><li>在类作用域之外访问类成员：<ul><li>静态成员：通过类名，或者该类的对象名、对象引用访问</li><li>非静态成员：通过类名，或者该类的对象名、对象引用、对象指针访问</li></ul></li></ul></li><li>文件作用域：不在前述作用域中出现的声明，就具有文件作用域。开始于声明点，结束与文件结束处。</li><li>命名空间作用域</li></ul><h4 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a>1.2 可见性</h4><ul><li><p>是对标识符的引用的角度来谈的概念，表示从内层作用域向外层作用域“看”时能看见什么。</p></li><li><p>如果标识在某处可见，那么就可以在该处引用这个标识符</p></li><li><p>如果标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见；对于两个嵌套作用域，若内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见（但仍在外层同名标识符的作用域中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">i = <span class="number">5</span>;</span><br><span class="line">&#123;<span class="keyword">int</span> i;</span><br><span class="line">i = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i= "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i= "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-对象的生存期"><a href="#2-对象的生存期" class="headerlink" title="2. 对象的生存期"></a>2. 对象的生存期</h3><h4 id="2-1-静态生存期"><a href="#2-1-静态生存期" class="headerlink" title="2.1 静态生存期"></a>2.1 静态生存期</h4><ul><li>该生存期与程序的运行期相同。</li><li>在文件作用域中声明的变量具有这种生存期；</li><li>在函数内部声明静态生存期对象，要冠以关键字static（static关键字声明的局部变量具有<strong>全局的寿命</strong>（即在整个程序中都存在）、局部的可见性）</li></ul><h4 id="2-2-动态生存期"><a href="#2-2-动态生存期" class="headerlink" title="2.2 动态生存期"></a>2.2 动态生存期</h4><ul><li>开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。</li><li>块作用域中声明的，没有用static修饰的对象，是动态生存期的对象（习惯称局部生存期对象）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">  <span class="comment">//a b 为静态局部变量，具有全局寿命，局部可见，只第一次进入函数时初始化</span></span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//c 为局部变量，具有动态生存期，每次进入函数时都初始化</span></span><br><span class="line">  a += <span class="number">2</span>; i += <span class="number">32</span>; c += <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"---OTHER---"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a;<span class="comment">//此处的 a 为静态局部变量，全局寿命，局部可见</span></span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">-10</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//b c 为局部变量，具有动态生存期</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"---MAIN---"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  c += <span class="number">8</span>; other();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"---MAIN---"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  c += <span class="number">10</span>; other();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">---MAIN---</span></span><br><span class="line"><span class="comment">i:1 a:0 b:-10 c:0</span></span><br><span class="line"><span class="comment">---OTHER---</span></span><br><span class="line"><span class="comment">i:33 a:4 b:0 c:15</span></span><br><span class="line"><span class="comment">---MAIN---</span></span><br><span class="line"><span class="comment">i:33 a:0 b:-10 c:8</span></span><br><span class="line"><span class="comment">---OTHER---</span></span><br><span class="line"><span class="comment">i:75 a:6 b:4 c:15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-类的静态成员"><a href="#3-类的静态成员" class="headerlink" title="3. 类的静态成员"></a>3. 类的静态成员</h3><ul><li>类的静态成员是用static修饰的，属于整个类而不属于对象</li></ul><h4 id="3-1-静态数据成员"><a href="#3-1-静态数据成员" class="headerlink" title="3.1 静态数据成员"></a>3.1 静态数据成员</h4><ul><li>用关键字static声明</li><li>为该类的所有对象共享，具有静态生存期</li><li>必须在类外定义和初始化，用::来指明所属的类</li></ul><h4 id="3-2-静态函数成员"><a href="#3-2-静态函数成员" class="headerlink" title="3.2 静态函数成员"></a>3.2 静态函数成员</h4><p>上面的例子中，我们发现类中定义的函数都是属于对象的，也就是说必须有相应的对象我们才能够调用如getX()、showCount()这样的函数。但是由于我们定义了静态的数据成员，它不属于任一对象，那么我们如何在没有初始化对象的时候就知道当前的count数量呢？于是我们需要定义静态函数成员。</p><ul><li>对于非静态函数，每次调用都是用 对象名.函数名() 这样的形式，也就是函数能够清楚地知道是什么对象调用了它</li><li>对于静态函数，调用的时候不通过特定对象，所以一般不用来处理属于对象的非静态数据，而专门用来处理整个类的静态数据。（如果非要处理属于对象的数据，就需要将希望其处理的这个对象作为参数传给它）</li></ul><h3 id="4-类的友元"><a href="#4-类的友元" class="headerlink" title="4. 类的友元"></a>4. 类的友元</h3><ul><li>是C++提供的一种破坏数据封装和数据隐藏的机制</li><li>通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。</li><li>为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。</li></ul><h4 id="4-1-友元函数"><a href="#4-1-友元函数" class="headerlink" title="4.1 友元函数"></a>4.1 友元函数</h4><ul><li>友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected成员</li><li>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。</li><li>访问对象中的成员必须通过对象名。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span> <span class="comment">//Point类声明</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//外部接口</span></span><br><span class="line">Point(<span class="keyword">int</span> x=<span class="number">0</span>, <span class="keyword">int</span> y=<span class="number">0</span>) : x(x), y(y) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">float</span> <span class="title">dist</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>: <span class="comment">//私有数据成员</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dist</span><span class="params">( Point&amp; a, Point&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> x = a.x - b.x;</span><br><span class="line">  <span class="keyword">double</span> y = a.y - b.y;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x * x + y * y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point p1(1, 1), p2(4, 5);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">"The distance is: "</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dist(p1, p2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">The distance is: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>思考：dist传的是a和b的引用而不是直接传值（对象），好处和坏处？</li></ul><p>好处：效率高，不需要传递整个对象而只是引用</p><p>坏处：安全隐患，引用是双向传递，有可能会不小心更改a和b原数据</p><h4 id="4-2-友元类"><a href="#4-2-友元类" class="headerlink" title="4.2 友元类"></a>4.2 友元类</h4><ul><li>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。</li><li>声明语法：将友元类名在另一个类中使用friend修饰说明。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//友元类举例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">a.x=i;<span class="comment">//注意这里为了B类直接通过对象访问到A类的私有成员x，需要在A类中定义友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">display</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>类的友元关系是单向的：声明B类是A类的友元 ≠ A类是B类的友元</li></ul><h3 id="5-共享数据的保护"><a href="#5-共享数据的保护" class="headerlink" title="5. 共享数据的保护"></a>5. 共享数据的保护</h3><ul><li>既需要共享数据，又需要保证共享数据的安全性，即不被修改。则可以定义为const常类型。</li></ul><h4 id="5-1-常类型"><a href="#5-1-常类型" class="headerlink" title="5.1 常类型"></a>5.1 常类型</h4><ul><li>常对象：必须初始化，不能被更新 </li><li>常成员：常数据成员、常成员函数</li><li>常引用：被引用的对象不能被更新 </li><li>（常数组：被引用数组不能被修改）</li><li>（常指针：指向常量的指针）</li></ul><h5 id="5-1-1-常对象"><a href="#5-1-1-常对象" class="headerlink" title="5.1.1 常对象"></a>5.1.1 常对象</h5><p>—— const 类名 对象名</p><p>常成员函数可以被非常对象调用，但常对象不可调用非常成员函数。</p><p>（一个const常对象调用的函数只能是类中的const修饰的常成员函数。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i,<span class="keyword">int</span> j) &#123;x=i; y=j;&#125;</span><br><span class="line">                     ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="keyword">const</span> <span class="title">a</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>; <span class="comment">//a是常对象，不能被更新</span></span><br></pre></td></tr></table></figure><h5 id="5-1-2-常成员"><a href="#5-1-2-常成员" class="headerlink" title="5.1.2 常成员"></a>5.1.2 常成员</h5><p>如果在定义类的成员函数的时候，里面的操作本就没有打算修改成员函数的值，那么可以把函数定义成const类型，这样之后使用会更加方便。</p><ul><li>常成员函数 —— 类型说明符 函数名（参数表）const；<ul><li>const关键字可以被用于参与对重载函数的区分</li><li>通过常对象只能调用它的常成员函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  R(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2) : r1(r1), r2(r2) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> r1, r2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; r1 &lt;&lt; <span class="string">":"</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R::print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; r1 &lt;&lt; <span class="string">";"</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">R <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  a.<span class="built_in">print</span>(); <span class="comment">//调用void print()</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> R <span class="title">b</span><span class="params">(<span class="number">20</span>,<span class="number">52</span>)</span></span>; </span><br><span class="line">  b.<span class="built_in">print</span>(); <span class="comment">//调用void print() const</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常数据成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       A(<span class="keyword">int</span> i);</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> b;  <span class="comment">//静态常数据成员，只初始化一次</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A::b=<span class="number">10</span>;</span><br><span class="line">A::A(<span class="keyword">int</span> i) : a(i) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">":"</span> &lt;&lt; b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立对象a和b，并以100和0作为初值，分别调用构造函数，</span></span><br><span class="line"><span class="comment">//通过构造函数的初始化列表给对象的常数据成员赋初值</span></span><br><span class="line">  A a1(100), a2(0);</span><br><span class="line">  a1.<span class="built_in">print</span>();<span class="comment">// 100:10</span></span><br><span class="line">  a2.<span class="built_in">print</span>();<span class="comment">// 0:10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-3-常引用"><a href="#5-1-3-常引用" class="headerlink" title="5.1.3 常引用"></a>5.1.3 常引用</h5><p> —— const 类型说明符 &amp;引用名</p><p>在友元中用常引用做参数，既能获得较高执行效率，又能保证实参的安全性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span> <span class="comment">//Point类定义</span></span><br><span class="line"><span class="keyword">public</span>:          <span class="comment">//外部接口</span></span><br><span class="line">       Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)</span><br><span class="line">    : x(x), y(y) &#123; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">friend</span> <span class="keyword">float</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point &amp;p1,<span class="keyword">const</span> Point &amp;p2)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:         <span class="comment">//私有数据成员</span></span><br><span class="line">       <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> x = p1.x - p2.x; <span class="comment">//只能引用，不能修改</span></span><br><span class="line">       <span class="keyword">double</span> y = p1.y - p2.y;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x+y*y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  <span class="comment">//主函数</span></span><br><span class="line">       const Point myp1(1, 1), myp2(4, 5);    </span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"The distance is: "</span>;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; dist(myp1, myp2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第六章-数组、指针和字符串"><a href="#第六章-数组、指针和字符串" class="headerlink" title="第六章 数组、指针和字符串"></a>第六章 数组、指针和字符串</h2><h3 id="6-1-数组的定义和初始化"><a href="#6-1-数组的定义和初始化" class="headerlink" title="6.1 数组的定义和初始化"></a>6.1 数组的定义和初始化</h3><p>略。</p><h3 id="6-2-数组作为函数的参数"><a href="#6-2-数组作为函数的参数" class="headerlink" title="6.2 数组作为函数的参数"></a>6.2 数组作为函数的参数</h3><p>略。</p><h3 id="6-3-对象数组"><a href="#6-3-对象数组" class="headerlink" title="6.3 对象数组"></a>6.3 对象数组</h3><ul><li>例如：Point a[2] = {Point(1,2), Point(1,3)};</li><li>数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象。</li></ul><h4 id="6-3-1-数组元素的构造和析构"><a href="#6-3-1-数组元素的构造和析构" class="headerlink" title="6.3.1 数组元素的构造和析构"></a>6.3.1 数组元素的构造和析构</h4><ul><li>元素所属的类不声明构造函数，则采用默认构造函数。</li><li>各元素对象的初值要求为相同的值时，可以声明具有默认形参值的构造函数。</li><li>各元素对象的初值要求为不同的值时，需要声明带形参的构造函数。</li><li>当数组中每一个对象被删除时，系统都要调用一次析构函数。</li></ul><h3 id="6-4-基于范围的for循环"><a href="#6-4-基于范围的for循环" class="headerlink" title="6.4 基于范围的for循环"></a>6.4 基于范围的for循环</h3><ul><li>for (int x : array) {}</li></ul><h3 id="6-5-指针的定义和运算"><a href="#6-5-指针的定义和运算" class="headerlink" title="6.5 指针的定义和运算"></a>6.5 指针的定义和运算</h3><ul><li>内存空间的访问方式：1. 通过变量名；2. 通过地址</li></ul><h4 id="6-5-1-指针的概念"><a href="#6-5-1-指针的概念" class="headerlink" title="6.5.1 指针的概念"></a>6.5.1 指针的概念</h4><ul><li>指针：内存地址，用于间接访问内存单元</li><li>指针变量：用于存放地址的变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>* ptr = &amp;i;<span class="comment">//指向int变量的指针</span></span><br><span class="line"><span class="comment">//ifi = 3;</span></span><br><span class="line"><span class="comment">//then*ptr = 3;</span></span><br><span class="line"><span class="comment">//ptr = &amp;i = i所在的地址</span></span><br></pre></td></tr></table></figure><h4 id="6-5-2-指针的初始化和赋值"><a href="#6-5-2-指针的初始化和赋值" class="headerlink" title="6.5.2 指针的初始化和赋值"></a>6.5.2 指针的初始化和赋值</h4><ul><li>语法形式：存储类型 数据类型 *指针名 = 初始地址</li><li>例如：int *pa = &amp;a         </li><li>a必须提前声明且变量类型和指针类型一致；可以用一个已有合法值的指针去初始化另一个指针变量，不要用一个内部非静态变量去初始化static指针</li><li>指针空值 nullptr，是表达更准确，类型安全的指针</li><li>可以声明void类型的指针：void *pv；不可以声明void类型的变量</li><li></li></ul><h5 id="指向常量的指针-amp-指针类型的常量"><a href="#指向常量的指针-amp-指针类型的常量" class="headerlink" title="指向常量的指针 &amp; 指针类型的常量"></a>指向常量的指针 &amp; 指针类型的常量</h5><ul><li><p>指向常量的指针：const int* p1 = &amp;a</p><ul><li><p>不能通过指向常量的指针来改变所指对象的值，但指针本身可以改变，可以指向另外的对象</p></li><li><p>如果希望一个指针是一个只读的指针，可以访问内存空间中的内容但是不能进行改写和覆盖，那么可以将其定义为一个const指针</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a; <span class="comment">//p1是指向常量的指针</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">p1 = &amp;b; <span class="comment">//正确，p1本身的值可以改变</span></span><br><span class="line">*p1 = <span class="number">1</span>; <span class="comment">//编译时出错，不能通过p1改变所指的对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>指针类型的常量：int * const p2 = &amp;a</p><ul><li><p>若声明指针常量，则指针本身的值不能被改变</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">p2 = &amp;b; <span class="comment">//错误，p2是指针常量，值不能改变</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-5-3-指针的算术运算、关系运算"><a href="#6-5-3-指针的算术运算、关系运算" class="headerlink" title="6.5.3 指针的算术运算、关系运算"></a>6.5.3 指针的算术运算、关系运算</h4><h5 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h5><ul><li>指针的加减操作意义是指向下一个或前一个完整数据的起始值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short a[<span class="number">4</span>];</span><br><span class="line">short *pa = a;</span><br><span class="line"><span class="comment">//*pa等同于a[0]</span></span><br><span class="line"><span class="comment">//*(pa+1)等同于a[1]</span></span><br><span class="line"><span class="comment">//*(pa+2)等同于a[2]</span></span><br></pre></td></tr></table></figure><h5 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h5><ul><li>指向相同类型数据的指针之间可以进行各种关系运算</li><li>指向不同数据类型的指针，以及指针与一般整数变量之间的关系运算是无意义的</li><li>指针可以和零之间进行等于或不等于的关系运算（判空）<ul><li>例如 p==0 或 p!=0</li></ul></li></ul><h3 id="6-6-指针与数组"><a href="#6-6-指针与数组" class="headerlink" title="6.6 指针与数组"></a>6.6 指针与数组</h3><ul><li>定义与赋值：int a[10], *pa; pa = &amp;a[0] 或 pa = a</li><li>等效的形式：a[i] , *(pa+i), *(a+i), pa[i]</li><li>用指针数组来表示二维数组的时候，数组里面每一个元素都是一个指针，分别指向一个数组。这种表示和二维数组最大得不同就是，指针数组的数组元素之间的内存不一定需要连续，但是二维数组的各行各列内存是连续的</li></ul><h3 id="6-7-指针与函数"><a href="#6-7-指针与函数" class="headerlink" title="6.7 指针与函数"></a>6.7 指针与函数</h3><h4 id="6-7-1-指针类型的函数"><a href="#6-7-1-指针类型的函数" class="headerlink" title="6.7.1 指针类型的函数"></a>6.7.1 指针类型的函数</h4><ul><li>返回值是指针类型</li><li>定义：存储类型 数据类型 *函数名(){};</li><li>不要将非静态局部地址用作函数的返回值</li></ul><p>错误的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span>* ptr= function();</span><br><span class="line">    *prt=<span class="number">5</span>; <span class="comment">//危险的访问！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local=<span class="number">0</span>; <span class="comment">//非静态局部变量作用域和寿命都仅限于本函数体内</span></span><br><span class="line">    <span class="keyword">return</span> &amp;local;</span><br><span class="line">&#125;<span class="comment">//函数运行结束时，变量local被释</span></span><br></pre></td></tr></table></figure><p>正确的例子1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>]; <span class="comment">//主函数中定义的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">search</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;<span class="built_in">array</span>[i];</span><br><span class="line">    <span class="keyword">int</span>* zeroptr= search(<span class="built_in">array</span>, <span class="number">10</span>);  <span class="comment">//将主函数中数组的首地址传给子函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">search</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> num)</span></span>&#123; <span class="comment">//指针a指向主函数中定义的数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">      <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> &amp;a[i]; <span class="comment">//返回的地址指向的元素是在主函数中定义的</span></span><br><span class="line">&#125;<span class="comment">//函数运行结束时，a[i]的地址仍有</span></span><br></pre></td></tr></table></figure><p>正确的例子2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">newintvar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span>* intptr= newintvar();</span><br><span class="line">    *intptr=<span class="number">5</span>; <span class="comment">//访问的是合法有效的地址</span></span><br><span class="line">    <span class="keyword">delete</span> intptr; <span class="comment">//如果忘记在这里释放，会造成内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">newintvar</span> <span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回的地址指向的是动态分配的空间</span></span><br><span class="line">&#125;<span class="comment">//函数运行结束时，p中的地址仍有效</span></span><br></pre></td></tr></table></figure><h4 id="6-7-2-指向函数的指针"><a href="#6-7-2-指向函数的指针" class="headerlink" title="6.7.2 指向函数的指针"></a>6.7.2 指向函数的指针</h4><ul><li>函数指针指向函数的起始地址（指向的是程序代码存储区）</li><li>定义：存储类型 数据类型 (*函数指针名)();     //如果没有这对括号，那么定义的就是返回值为指针类型的函数</li><li>典型用途：实现函数回调<ul><li>通过函数指针调用的函数<ul><li>例如将函数的指针作为参数传递给一个函数，使得在处理相似事件的时候可以灵活使用不同的方法</li></ul></li><li>调用者不关心谁是被调用者<ul><li>需要知道存在一个具有特定原型和限制条件的被调用函数</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>(*func)(<span class="keyword">int</span>, <span class="keyword">int</span>)&#123; </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">return</span> func(a,b);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> <span class="built_in">max</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> (a&gt;b)?a:b; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> <span class="built_in">min</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> (a&lt;b)?a:b; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> sum(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a+b &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> main()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> a, b, res;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span></span></span><br><span class="line"><span class="function"><span class="params">  res = compute(a, b, &amp;<span class="built_in">max</span>);<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">  res = compute(a, b, &amp;<span class="built_in">min</span>);<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">  res = compute(a, b, &amp;sum);<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="6-8-对象指针"><a href="#6-8-对象指针" class="headerlink" title="6.8 对象指针"></a>6.8 对象指针</h3><ul><li>类名 *对象指针名  :   TreeNode* root;</li><li>访问对象：root-&gt;val</li><li>this指针：隐含与类的每一个非静态成员函数中。当通过一个对象调用成员函数时，系统先将该对象的地址赋给this指针，然后调用成员函数，成员函数对对象的数据成员进行操作时，就隐含使用了this指针。</li></ul><h3 id="6-9-动态内存分配"><a href="#6-9-动态内存分配" class="headerlink" title="6.9 动态内存分配"></a>6.9 动态内存分配</h3><h4 id="6-9-1-动态分配与释放内存"><a href="#6-9-1-动态分配与释放内存" class="headerlink" title="6.9.1 动态分配与释放内存"></a>6.9.1 动态分配与释放内存</h4><p>动态申请内存操作符 new —— new 类型名T(初始化参数列表)</p><ul><li>功能：在程序执行期间，申请用语存储T类型对象的内存空间，并依初值列表赋以初值</li><li>结果值：T类型的指针，指向新分配的内存；失败：抛出异常</li></ul><p>释放内存操作符delete —— delete 指针p</p><ul><li><p>功能：释放指针p所指向的内存。p必须是new操作的返回值。</p></li><li><p>注意：是删除指针指向的内存而不是指针自己。delete之后p可以重新进行赋值。</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Point *ptr1 = <span class="keyword">new</span> Point; <span class="comment">//调用默认构造函数</span></span><br><span class="line">  <span class="keyword">delete</span> ptr1; <span class="comment">//删除对象，自动调用析构函数</span></span><br><span class="line"></span><br><span class="line">  ptr1 = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//ptr1可以继续使用</span></span><br><span class="line">  <span class="keyword">delete</span> ptr1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-9-2-申请和释放动态数组"><a href="#6-9-2-申请和释放动态数组" class="headerlink" title="6.9.2 申请和释放动态数组"></a>6.9.2 申请和释放动态数组</h4><p>分配：new 类型名T[数组长度]; （多维数组：new 类型名T[维度1][维度2] </p><p>释放：delete[] 数组名p （p是new分配得到的数组首地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> (*cp)[<span class="number">9</span>][<span class="number">8</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>][<span class="number">9</span>][<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">      *(*(*(cp + i) + j) + k) =（i * <span class="number">100</span> + j * <span class="number">10</span> + k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; cp[i][j][k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] cp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将动态数组封装成类 </p><ul><li>更加简洁,便于管理</li><li>可以在访问数组元素前检查下标是否越界</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span> <span class="comment">//类的声明同例6-16 … &#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayOfPoints</span> &#123;</span> <span class="comment">//动态数组类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ArrayOfPoints(<span class="keyword">int</span> <span class="built_in">size</span>) : <span class="built_in">size</span>(<span class="built_in">size</span>) &#123;</span><br><span class="line">  points = <span class="keyword">new</span> Point[<span class="built_in">size</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  ~ArrayOfPoints() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleting..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] points;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function">Point&amp; <span class="title">element</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">return</span> points[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Point *points; <span class="comment">//指向动态数组首地址</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//数组大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the count of points: "</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; count;</span><br><span class="line">  <span class="function">ArrayOfPoints <span class="title">points</span><span class="params">(count)</span></span>; <span class="comment">//创建数组对象</span></span><br><span class="line">  points.element(<span class="number">0</span>).<span class="built_in">move</span>(<span class="number">5</span>, <span class="number">0</span>); <span class="comment">//访问数组元素的成员</span></span><br><span class="line">  points.element(<span class="number">1</span>).<span class="built_in">move</span>(<span class="number">15</span>, <span class="number">20</span>); <span class="comment">//访问数组元素的成员</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">Please enter the number of points:<span class="number">2</span></span><br><span class="line">Default Constructor called.</span><br><span class="line">Default Constructor called.</span><br><span class="line">Deleting...</span><br><span class="line">Destructor called.</span><br><span class="line">Destructor called.</span><br></pre></td></tr></table></figure><h3 id="6-10-智能指针"><a href="#6-10-智能指针" class="headerlink" title="6.10 智能指针"></a>6.10 智能指针</h3><ul><li>unique_ptr：不允许多个指针共享资源，可以用标准库中的move函数转移指针</li><li>shared_ptr：多个指针共享资源</li><li>weak_ptr：可复制shared_ptr，但其构造或者释放对资源不产生影响</li></ul><h3 id="6-11-vector对象"><a href="#6-11-vector对象" class="headerlink" title="6.11 vector对象"></a>6.11 vector对象</h3><ul><li>注意：vector对象名不能当做数组的头指针使用</li></ul><h3 id="6-12-对象复制与移动"><a href="#6-12-对象复制与移动" class="headerlink" title="6.12 对象复制与移动"></a>6.12 对象复制与移动</h3><h4 id="6-12-1-深层复制和浅层复制"><a href="#6-12-1-深层复制和浅层复制" class="headerlink" title="6.12.1 深层复制和浅层复制"></a>6.12.1 深层复制和浅层复制</h4><ul><li>浅层复制：实现对象间数据元素的一一复制</li><li>深层复制：当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制。（防止调用析构函数时候出错）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point &#123; //类的声明同例6-16</span><br><span class="line">&#125;;</span><br><span class="line">class ArrayOfPoints &#123;</span><br><span class="line">public:</span><br><span class="line">ArrayOfPoints(const ArrayOfPoints&amp; pointsArray);</span><br><span class="line">//其他成员同例6-18</span><br><span class="line">&#125;;</span><br><span class="line">ArrayOfPoints::ArrayOfPoints(const ArrayOfPoints&amp; v) &#123;</span><br><span class="line">    size = v.size;</span><br><span class="line">    points = new Point[size];</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    points[i] = v.points[i];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">//同例6-20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-12-2-移动构造"><a href="#6-12-2-移动构造" class="headerlink" title="6.12.2 移动构造"></a>6.12.2 移动构造</h4><ul><li>C++11之前，将源对象的状态转移到目标对象只能通过复制，但有时候我们没有必要复制，只需要移动。</li><li>C++11引入移动定义：源对象资源的控制权全部交给目标对象。</li><li>什么时候触发：有可被利用的临时对象</li><li>移动构造函数：class_name ( class_name &amp;&amp; )<ul><li>&amp;&amp;是右值引用，&amp;是左值引用</li><li>左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值指表达式结束时就不再存在的临时对象</li></ul></li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-10-04-082609.png" alt="image-20201004162608854"></p><ul><li>使用深层复制构造函数：返回时构造临时对象，动态分配将临时对象返回到主调函数，然后删除临时对象。</li><li>使用移动构造函数：将要返回的局部对象转移到主调函数，省去了构造和删除临时对象的过程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IntNum(<span class="keyword">const</span> IntNum &amp; n) : xptr(<span class="keyword">new</span> <span class="keyword">int</span>(*n.xptr))&#123;<span class="comment">//复制构造函数</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling copy constructor..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IntNum(IntNum &amp;&amp; n): xptr( n.xptr)&#123; <span class="comment">//移动构造函数</span></span><br><span class="line"> n.xptr = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling move constructor..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-13-字符串"><a href="#6-13-字符串" class="headerlink" title="6.13 字符串"></a>6.13 字符串</h3><h4 id="6-13-1-C风格字符串"><a href="#6-13-1-C风格字符串" class="headerlink" title="6.13.1 C风格字符串"></a>6.13.1 C风格字符串</h4><ul><li>例：”program”</li><li>各字符连续、顺序存放，每个字符占一个字节，以‘\0’结尾，相当于一个隐含创建的字符常量数组</li><li>“program”出现在表达式中，表示这一char数组的首地址</li><li>首地址可以赋给char常量指针：const char *STRING1 = “program”;</li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-10-04-083950.png" alt="image-20201004163950472"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例题：</span></span><br><span class="line"><span class="comment">//函数F定义如下：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">7</span>] = &#123; <span class="string">'p'</span>, <span class="string">'r'</span>, <span class="string">'o'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用F()时，将会出现：</span></span><br><span class="line"><span class="comment">//输出program以及任意长度的随机字符后换行（而非编译错误）</span></span><br></pre></td></tr></table></figure><p><strong>用字符数组表示字符串的缺点</strong></p><ul><li>执行连接、拷贝、比较等操作，都需要显式调用库函数，很麻烦</li><li>当字符串长度很不确定时，需要用new动态创建字符数组，最后要用delete释放，很繁琐</li><li>字符串实际长度大于为它分配的空间时，会产生数组下标越界的错误</li></ul><h4 id="6-13-2-string类"><a href="#6-13-2-string类" class="headerlink" title="6.13.2 string类"></a>6.13.2 string类</h4><ul><li>string实际上是对字符数组操作的封装</li></ul><p>如何输入整行字符串：</p><ul><li><p>用cin的&gt;&gt;操作符输入字符串，会以空格作为分隔符，空格后的内容会在下一回输入时被读取</p></li><li><p>getline可以输入整行字符串（要包string头文件），例如：getline(cin, s2);</p></li><li><p>输入字符串时使用其它分隔符作为字符串结束的标志（例如逗号、分号）：getline(cin, s2, ‘,’);</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">string</span> city, state;</span><br><span class="line">    getline(<span class="built_in">cin</span>, city, <span class="string">','</span>);</span><br><span class="line">    getline(<span class="built_in">cin</span>, state);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"City:"</span> &lt;&lt; city &lt;&lt; “ State:<span class="string">" &lt;&lt; state &lt;&lt; endl;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第七章-继承与派生"><a href="#第七章-继承与派生" class="headerlink" title="第七章 继承与派生"></a>第七章 继承与派生</h2><h3 id="7-1-继承的基本概念和语法"><a href="#7-1-继承的基本概念和语法" class="headerlink" title="7.1 继承的基本概念和语法"></a>7.1 继承的基本概念和语法</h3><h4 id="7-1-1-继承与派生概述"><a href="#7-1-1-继承与派生概述" class="headerlink" title="7.1.1 继承与派生概述"></a>7.1.1 继承与派生概述</h4><ul><li>继承与派生是同一过程从不同的角度看<ul><li>保持已有类的特性而构造新类的过程称为继承</li><li>在已有类的基础上新增自己的特性而产生新类的过程称为派生。</li></ul></li><li>被继承的已有类称为基类（或父类）</li><li>派生出的新类称为派生类（或子类）</li><li>直接参与派生出某类的基类称为直接基类</li><li>基类的基类甚至更高层的基类称为间接基类</li></ul><h4 id="7-1-2-继承与派生的目的"><a href="#7-1-2-继承与派生的目的" class="headerlink" title="7.1.2 继承与派生的目的"></a>7.1.2 继承与派生的目的</h4><ul><li>继承的目的：实现设计与代码的重用。</li><li>派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。</li></ul><h4 id="7-1-3-派生类的构成"><a href="#7-1-3-派生类的构成" class="headerlink" title="7.1.3 派生类的构成"></a>7.1.3 派生类的构成</h4><ul><li>吸收基类成员<ul><li>默认情况下派生类包含了全部基类中除构造和析构函数之外的所有成员</li><li>C++11规定可以用using语句继承基类构造函数</li></ul></li><li>改造基类成员<ul><li>隐藏或者覆盖外层同名成员</li></ul></li><li>添加新的成员</li></ul><h4 id="7-1-3-单继承时派生类的定义"><a href="#7-1-3-单继承时派生类的定义" class="headerlink" title="7.1.3 单继承时派生类的定义"></a>7.1.3 单继承时派生类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived ();</span><br><span class="line">  ~Derived ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-1-4-多继承时派生类的定义"><a href="#7-1-4-多继承时派生类的定义" class="headerlink" title="7.1.4 多继承时派生类的定义"></a>7.1.4 多继承时派生类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">private</span> Base2</span><br><span class="line">&#123;<span class="comment">//注意：每一个“继承方式public/private”，只用于限制对紧随其后之基类的继承。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived ();</span><br><span class="line">  ~Derived ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-2-继承方式"><a href="#7-2-继承方式" class="headerlink" title="7.2 继承方式"></a>7.2 继承方式</h3><h4 id="7-2-1-继承方式简介"><a href="#7-2-1-继承方式简介" class="headerlink" title="7.2.1 继承方式简介"></a>7.2.1 继承方式简介</h4><p>不同继承方式的影响主要体现在：</p><ul><li>派生类<strong>成员</strong>对基类成员的访问权限</li><li>通过派生类<strong>对象</strong>对基类成员的访问权限</li></ul><p>三种继承方式：</p><ul><li>公有继承</li><li>私有继承</li><li>保护继承</li></ul><h4 id="7-2-2-公有继承-public"><a href="#7-2-2-公有继承-public" class="headerlink" title="7.2.2 公有继承 public"></a>7.2.2 公有继承 public</h4><ul><li>继承的访问控制<ul><li>基类的public和protected成员：访问属性在派生类中保持不变</li><li>基类的private成员：不可直接访问。</li></ul></li><li>访问权限<ul><li>派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；</li><li>通过派生类的对象：只能访问public成员。</li></ul></li></ul><h4 id="7-2-3-私有继承-private"><a href="#7-2-3-私有继承-private" class="headerlink" title="7.2.3 私有继承 private"></a>7.2.3 私有继承 private</h4><ul><li><p>继承的访问控制</p></li><li><ul><li>基类的<strong>public</strong>和<strong>protected</strong>成员：都以<strong>private</strong>身份出现在派生类中</li><li>基类的private成员：<strong>不可直接访问</strong>。</li></ul></li><li><p>访问权限</p></li><li><ul><li>派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；</li><li>通过派生类的对象：不能直接访问从基类继承的任何成员。</li></ul></li></ul><h4 id="7-2-4-保护继承-protected"><a href="#7-2-4-保护继承-protected" class="headerlink" title="7.2.4 保护继承 protected"></a>7.2.4 保护继承 protected</h4><ul><li><p>继承的访问控制</p></li><li><ul><li>基类的<strong>public</strong>和<strong>protected</strong>成员：都以<strong>protected</strong>身份出现在派生类中；</li><li>基类的<strong>private</strong>成员：<strong>不可直接访问</strong>。</li></ul></li><li><p>访问权限</p></li><li><ul><li>派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；</li><li>通过派生类的对象：不能直接访问从基类继承的任何成员。</li></ul></li><li><p>protected 成员的特点与作用</p></li><li><ul><li>对建立其所在类对象的模块来说，它与 private 成员的性质相同。</li><li>对于其派生类来说，它与 public 成员的性质相同。</li><li>既实现了数据隐藏，又方便继承，实现代码重用。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.x = <span class="number">5</span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> B:function() &#123;</span><br><span class="line">    x = <span class="number">5</span>;   <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果派生类有多个基类，也就是多继承时，可以用不同的方式继承每个基类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showA</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showB</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">private</span> B &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showC</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">A::setA</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    a=x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::setB</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    b=x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C::setC</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//派生类成员直接访问基类的</span></span><br><span class="line">    <span class="comment">//公有成员</span></span><br><span class="line">    setA(x); </span><br><span class="line">    setB(y); </span><br><span class="line">    c = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他函数实现略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    obj.setA(<span class="number">5</span>);</span><br><span class="line">    obj.showA();</span><br><span class="line">    obj.setC(<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>);</span><br><span class="line">    obj.showC();</span><br><span class="line"><span class="comment">// obj.setB(6);  错误因为B是通过私有继承到C类，B类内的私有成员在C类外不能通过对象访问</span></span><br><span class="line"><span class="comment">// obj.showB(); 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-基类与派生类类型转换"><a href="#7-3-基类与派生类类型转换" class="headerlink" title="7.3 基类与派生类类型转换"></a>7.3 基类与派生类类型转换</h3><ul><li><p>公有派生类对象可以被当作基类的对象使用，反之则不可。</p></li><li><ul><li>派生类的对象可以隐含转换为基类对象；</li><li>派生类的对象可以初始化基类的引用；</li><li>派生类的指针可以隐含转换为基类的指针。</li></ul></li><li><p>通过基类对象名、指针只能使用从基类继承的成员。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span> <span class="comment">//基类Base1定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::display()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">public</span> Base1 &#123; <span class="comment">//公有派生类Base2定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::display()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base2 &#123; <span class="comment">//公有派生类Derived定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::display()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Base1 *ptr)</span> </span>&#123;  <span class="comment">//参数为指向基类对象的指针</span></span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();     <span class="comment">//"对象指针-&gt;成员名"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    <span class="comment">//主函数</span></span><br><span class="line">    Base1 base1;    <span class="comment">//声明Base1类对象</span></span><br><span class="line">    Base2 base2;    <span class="comment">//声明Base2类对象</span></span><br><span class="line">    Derived derived;    <span class="comment">//声明Derived类对象</span></span><br><span class="line"></span><br><span class="line">    fun(&amp;base1);    <span class="comment">//用Base1对象的指针调用fun函数</span></span><br><span class="line">    fun(&amp;base2);    <span class="comment">//用Base2对象的指针调用fun函数</span></span><br><span class="line">    fun(&amp;derived); <span class="comment">//用Derived对象的指针调用fun函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">Base1::display()</span></span><br><span class="line"><span class="comment">Base1::display()</span></span><br><span class="line"><span class="comment">Base1::display()</span></span><br><span class="line"><span class="comment">如果要达到我们想要的效果先，需要定义虚函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>建议：不要重新定义继承而来的非虚函数</li></ul><h3 id="7-4-派生类的构造和析构"><a href="#7-4-派生类的构造和析构" class="headerlink" title="7.4 派生类的构造和析构"></a>7.4 派生类的构造和析构</h3><h4 id="7-4-1-派生类的构造函数"><a href="#7-4-1-派生类的构造函数" class="headerlink" title="7.4.1 派生类的构造函数"></a>7.4.1 派生类的构造函数</h4><ul><li><p>默认情况</p></li><li><ul><li>基类的构造函数不被继承;</li><li>派生类需要定义自己的构造函数。</li></ul></li><li><p>C++11规定</p></li><li><ul><li>可用using语句继承基类构造函数，但是只能初始化从基类继承的成员。派生类新增成员可以通过类内初始值进行初始化。</li><li>语法形式：using B::B;</li></ul></li></ul><p><strong>建议</strong></p><ul><li>如果派生类有自己新增的成员，且需要通过构造函数初始化，则派生类要自定义构造函数。</li></ul><p><strong>若不继承基类的构造函数</strong></p><ul><li>派生类新增成员：派生类定义构造函数初始化；</li><li>继承来的成员：自动调用基类构造函数进行初始化；</li><li>派生类的构造函数需要给基类的构造函数传递参数。</li></ul><h5 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h5><ul><li>派生类只有一个直接基类的情况，是单继承。单继承时，派生类的构造函数只需要给一个直接基类构造函数传递参数。</li></ul><p>单继承时构造函数的定义语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">派生类名::派生类名(基类所需的形参，本类成员所需的形参):</span><br><span class="line">基类名(参数表), 本类成员初始化列表</span><br><span class="line">&#123;</span><br><span class="line">//其他初始化；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B();</span><br><span class="line">    B(<span class="keyword">int</span> i);</span><br><span class="line">    ~B();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::B() &#123;</span><br><span class="line">    b=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"B's default constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">B::B(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    b=i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"B's constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">B::~B() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"B's destructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C();</span><br><span class="line">    C(<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    ~C();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">C::C() &#123;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C's default constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">C::C(<span class="keyword">int</span> i,<span class="keyword">int</span> j): B(i), c(j)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C's constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">C::~C() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C's destructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C::print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    B::<span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">obj</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h5><ul><li>多继承时，有多个直接基类，如果不继承基类的构造函数，派生类构造函数需要给所有基类构造函数传递参数。我们来看一下语法规定</li></ul><p>多继承时构造函数的定义语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">派生类名::派生类名(参数表) : </span><br><span class="line">基类名1(基类1初始化参数表), </span><br><span class="line">基类名2(基类2初始化参数表), </span><br><span class="line">...</span><br><span class="line">基类名n(基类n初始化参数表), </span><br><span class="line">本类成员初始化列表</span><br><span class="line">&#123;</span><br><span class="line">        //其他初始化；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>派生类与基类的构造函数</p><ul><li><p>当基类有默认构造函数时</p></li><li><ul><li>派生类构造函数可以不向基类构造函数传递参数。</li><li>构造派生类的对象时，基类的默认构造函数将被调用。</li></ul></li><li><p>如需执行基类中带参数的构造函数</p></li><li><ul><li>派生类构造函数应为基类构造函数提供参数。</li></ul></li></ul><p>多继承且有对象成员时派生的构造函数定义语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">派生类名::派生类名(形参表):</span><br><span class="line">基类名1(参数), 基类名2(参数), ..., 基类名n(参数), </span><br><span class="line">本类成员（含对象成员）初始化列表</span><br><span class="line">&#123;</span><br><span class="line">        //其他初始化</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>构造函数的执行顺序</p><ol><li><p>调用基类构造函数。</p></li><li><ul><li>顺序按照它们被继承时声明的顺序（从左向右）。</li></ul></li><li><p>对初始化列表中的成员进行初始化。</p></li><li><ul><li>顺序按照它们在类中定义的顺序。</li><li>对象成员初始化时自动调用其所属类的构造函数。由初始化列表提供参数。</li></ul></li><li><p>执行派生类的构造函数体中的内容。</p></li></ol><h4 id="7-4-2-派生类的构造函数举例"><a href="#7-4-2-派生类的构造函数举例" class="headerlink" title="7.4.2 派生类的构造函数举例"></a>7.4.2 派生类的构造函数举例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span><span class="comment">//基类Base1，构造函数有参数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1(<span class="keyword">int</span> i) </span><br><span class="line">  &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructing Base1 "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span><span class="comment">//基类Base2，构造函数有参数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2(<span class="keyword">int</span> j) </span><br><span class="line">  &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructing Base2 "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> &#123;</span><span class="comment">//基类Base3，构造函数无参数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base3() </span><br><span class="line">  &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructing Base3 *"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base3 &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Derived(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): Base1(a), member2(d), member1(c), Base2(b)</span><br><span class="line">  <span class="comment">//此处的次序与构造函数的执行次序无关</span></span><br><span class="line">  <span class="comment">//执行的顺序应该按照本类进行多继承时候的基类排列顺序，然后是本类自己的成员函数定义的顺序</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base1 member1;</span><br><span class="line">    Base2 member2;</span><br><span class="line">    Base3 member3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-3-派生类复制构造函数"><a href="#7-4-3-派生类复制构造函数" class="headerlink" title="7.4.3 派生类复制构造函数"></a>7.4.3 派生类复制构造函数</h4><p>派生类未定义复制构造函数的情况</p><ul><li>编译器会在需要时生成一个隐含的复制构造函数；</li><li>先调用基类的复制构造函数；</li><li>再为派生类新增的成员执行复制。</li></ul><p>派生类定义了复制构造函数的情况</p><ul><li>一般都要为基类的复制构造函数传递参数。</li><li>复制构造函数只能接受一个参数，既用来初始化派生类定义的成员，也将被传递给基类的复制构造函数。</li><li>基类的复制构造函数形参类型是基类对象的引用，实参可以是派生类对象的引用</li><li>例如: C::C(const C &amp;c1): B(c1) {…}</li></ul><h4 id="7-4-4-派生类的析构函数"><a href="#7-4-4-派生类的析构函数" class="headerlink" title="7.4.4 派生类的析构函数"></a>7.4.4 派生类的析构函数</h4><ul><li>析构函数不被继承，派生类如果需要，要自行声明析构函数。</li><li>声明方法与无继承关系时类的析构函数相同。</li><li>不需要显式地调用基类的析构函数，系统会自动隐式调用。</li><li>先执行派生类析构函数的函数体，再调用基类的析构函数。</li></ul><h3 id="7-5-派生类成员的标识与访问"><a href="#7-5-派生类成员的标识与访问" class="headerlink" title="7.5 派生类成员的标识与访问"></a>7.5 派生类成员的标识与访问</h3><h4 id="7-5-1-访问从基类继承的成员"><a href="#7-5-1-访问从基类继承的成员" class="headerlink" title="7.5.1 访问从基类继承的成员"></a>7.5.1 访问从基类继承的成员</h4><p><strong>作用域限定</strong></p><p>当派生类与基类中有相同成员时：</p><ul><li>若未特别限定，则通过派生类对象使用的是派生类中的同名成员。</li><li>如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符（::）来限定。</li></ul><p><strong>二义性问题</strong></p><ul><li>如果从不同基类继承了同名成员，但是在派生类中没有定义同名成员，“<strong>派生类对象名或引用名.成员名</strong>”、“<strong>派生类指针-&gt;成员名</strong>”访问成员存在二义性问题</li><li>解决方式：1. 用类名限定；2. 同名隐藏</li></ul><p><strong>Derived类对象d的存储结构示意图</strong></p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-10-09-100024.png" alt="image-20201009180024326"></p><h4 id="7-5-2-虚基类"><a href="#7-5-2-虚基类" class="headerlink" title="7.5.2 虚基类"></a>7.5.2 虚基类</h4><ul><li><p>需要解决的问题</p></li><li><ul><li>当派生类从多个基类派生，而这些基类又共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性</li></ul></li><li><p>虚基类声明</p></li><li><ul><li>以virtual说明基类继承方式</li><li>例：class B1:virtual public B</li></ul></li><li><p>作用</p></li><li><ul><li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题</li><li>为最远的派生类提供唯一的基类成员，而不重复产生多次复制</li></ul></li><li><p>注意：</p></li><li><ul><li>在第一级继承时就要将共同基类设计为虚基类。</li></ul></li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-10-09-100229.png" alt="image-20201009180229499"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base0</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var0;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun0</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Member of Base0"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="comment">//定义派生类Derived </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Member of Derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    Derived d;</span><br><span class="line">    d.var0 = <span class="number">2</span>; <span class="comment">//直接访问虚基类的数据成员</span></span><br><span class="line">    d.fun0();     <span class="comment">//直接访问虚基类的函数成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="虚基类及其派生类构造函数"><a href="#虚基类及其派生类构造函数" class="headerlink" title="虚基类及其派生类构造函数"></a>虚基类及其派生类构造函数</h5><ul><li>建立对象时所指定的类称为<strong>最远派生类</strong>。</li><li>虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。</li><li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中为虚基类的构造函数列出参数。如果未列出，则表示调用该虚基类的默认构造函数。</li><li>在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，其他类对虚基类构造函数的调用被忽略。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base0</span> &#123;</span>   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base0(<span class="keyword">int</span> var) : var0(var) &#123; &#125;</span><br><span class="line">    <span class="keyword">int</span> var0;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun0</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Member of Base0"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Base1(<span class="keyword">int</span> var) : Base0(var) &#123; &#125;</span><br><span class="line">    <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2(<span class="keyword">int</span> var) : Base0(var) &#123; &#125;</span><br><span class="line">    <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> var) : Base0(var), Base1(var), Base2(var) </span><br><span class="line">   &#123; &#125;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Member of Derived"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    <span class="comment">//程序主函数</span></span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    d.var0 = <span class="number">2</span>; <span class="comment">//直接访问虚基类的数据成员</span></span><br><span class="line">    d.fun0();   <span class="comment">//直接访问虚基类的函数成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第八章-多态性"><a href="#第八章-多态性" class="headerlink" title="第八章 多态性"></a>第八章 多态性</h2><h3 id="8-1-运算符重载"><a href="#8-1-运算符重载" class="headerlink" title="8.1 运算符重载"></a>8.1 运算符重载</h3><h4 id="8-1-1-运算符重载的规则"><a href="#8-1-1-运算符重载的规则" class="headerlink" title="8.1.1 运算符重载的规则"></a>8.1.1 运算符重载的规则</h4><ul><li>C++ 几乎可以重载全部的运算符，而且只能够重载C++中已经有的。</li><li>不能重载的运算符：“.”、“.*”、“::”、“?:”</li><li>重载之后运算符的优先级和结合性都不会改变。</li><li>运算符重载是针对新类型数据的实际需要，对原有运算符进行适当的改造。</li></ul><h4 id="8-1-2-双目运算符重载为成员函数"><a href="#8-1-2-双目运算符重载为成员函数" class="headerlink" title="8.1.2 双目运算符重载为成员函数"></a>8.1.2 双目运算符重载为成员函数</h4><p>重载为类成员的运算符函数定义形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数类型  operator 运算符（形参）</span><br><span class="line">&#123;</span><br><span class="line">       ......</span><br><span class="line">&#125;</span><br><span class="line">参数个数=原操作数个数-1   （后置++、--除外）</span><br></pre></td></tr></table></figure><p><strong>双目运算符重载规则</strong></p><ul><li>如果要重载 B 为类成员函数，使之能够实现表达式 oprd1 B oprd2，其中 oprd1 为A 类对象，则 B 应被重载为 A 类的成员函数，形参类型应该是 oprd2 所属的类型。</li><li>经重载后，表达式 oprd1 B oprd2 相当于 oprd1.operator B(oprd2)</li></ul><p>例 : 复数类加减法运算重载为成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">要求:将+、-运算重载为复数类的成员函数。</span><br><span class="line">规则:实部和虚部分别相加减。</span><br><span class="line">操作数:两个操作数都是复数类的对象。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>) : real(r), imag(i) &#123; &#125;</span><br><span class="line">    <span class="comment">//运算符+重载成员函数</span></span><br><span class="line">  Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">//运算符-重载成员函数</span></span><br><span class="line">  Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">//输出复数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real;    <span class="comment">//复数实部</span></span><br><span class="line">    <span class="keyword">double</span> imag;    <span class="comment">//复数虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>&#123;</span><br><span class="line">  <span class="comment">//创建一个临时无名对象作为返回值 </span></span><br><span class="line">  <span class="keyword">return</span> Complex(real+c2.real, imag+c2.imag); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>&#123;</span><br><span class="line"> <span class="comment">//创建一个临时无名对象作为返回值</span></span><br><span class="line">    <span class="keyword">return</span> Complex(real-c2.real, imag-c2.imag); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;real&lt;&lt;<span class="string">", "</span>&lt;&lt;imag&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Complex c1(5, 4), c2(2, 10), c3;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c1 = "</span>; c1.<span class="built_in">display</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c2 = "</span>; c2.<span class="built_in">display</span>();</span><br><span class="line">    c3 = c1 - c2;   <span class="comment">//使用重载运算符完成复数减法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c3 = c1 - c2 = "</span>; c3.<span class="built_in">display</span>();</span><br><span class="line">    c3 = c1 + c2;   <span class="comment">//使用重载运算符完成复数加法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c3 = c1 + c2 = "</span>; c3.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-3-单目运算符重载为成员函数"><a href="#8-1-3-单目运算符重载为成员函数" class="headerlink" title="8.1.3 单目运算符重载为成员函数"></a>8.1.3 单目运算符重载为成员函数</h4><p><strong>前置单目运算符重载规则</strong></p><ul><li>如果要重载 U 为类成员函数，使之能够实现表达式 U oprd，其中 oprd 为A类对象，则 U 应被重载为 A 类的成员函数，无形参。</li><li>经重载后，表达式 U oprd 相当于 oprd.operator U()</li></ul><p><strong>后置单目运算符 ++和–重载规则</strong></p><ul><li>如果要重载 ++或–为类成员函数，使之能够实现表达式 oprd++ 或 oprd– ，其中 oprd 为A类对象，则 ++或– 应被重载为 A 类的成员函数，且具有一个 int 类型形参。</li><li>经重载后，表达式 oprd++ 相当于 oprd.operator ++(0)</li></ul><p><strong>例：重载前置++和后置++为时钟类成员函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">前置单目运算符，重载函数没有形参</span><br><span class="line">后置++运算符，重载函数需要有一个<span class="keyword">int</span>形参</span><br><span class="line">操作数是时钟类的对象。</span><br><span class="line">实现时间增加<span class="number">1</span>秒钟。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span><span class="comment">//时钟类定义</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Clock(<span class="keyword">int</span> hour = <span class="number">0</span>, <span class="keyword">int</span> minute = <span class="number">0</span>, <span class="keyword">int</span> second = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="comment">//前置单目运算符重载</span></span><br><span class="line">    Clock&amp; <span class="keyword">operator</span> ++ ();</span><br><span class="line">  <span class="comment">//后置单目运算符重载</span></span><br><span class="line">    Clock <span class="keyword">operator</span> ++ (<span class="keyword">int</span>);    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= hour &amp;&amp; hour &lt; <span class="number">24</span> &amp;&amp; <span class="number">0</span> &lt;= minute &amp;&amp; minute &lt; <span class="number">60</span></span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= second &amp;&amp; second &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hour = hour;</span><br><span class="line">        <span class="keyword">this</span>-&gt;minute = minute;</span><br><span class="line">        <span class="keyword">this</span>-&gt;second = second;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clock::showTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">//显示时间</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hour &lt;&lt; <span class="string">":"</span> &lt;&lt; minute &lt;&lt; <span class="string">":"</span> &lt;&lt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++：先+1再使用</span></span><br><span class="line"><span class="comment">//运算结果返回的是左值，所以源数据是可以被修改的，可用在之后的后置++定义</span></span><br><span class="line">Clock &amp; Clock::<span class="keyword">operator</span> ++ () &#123; </span><br><span class="line">    second++;</span><br><span class="line">    <span class="keyword">if</span> (second &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        second -= <span class="number">60</span>;  minute++;</span><br><span class="line">        <span class="keyword">if</span> (minute &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">          minute -= <span class="number">60</span>; hour = (hour + <span class="number">1</span>) % <span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置++：先使用后++</span></span><br><span class="line"><span class="comment">//运算结果返回的只是一个临时右值，是源数据的复制品</span></span><br><span class="line">Clock Clock::<span class="keyword">operator</span> ++ (<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="comment">//注意形参表中的整型参数</span></span><br><span class="line">    Clock old = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);  <span class="comment">//调用前置“++”运算符，更能保证一致性</span></span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">myClock</span><span class="params">(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First time output: "</span>;</span><br><span class="line">    myClock.showTime();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Show myClock++:    "</span>;</span><br><span class="line">    (myClock++).showTime();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Show ++myClock:    "</span>;</span><br><span class="line">    (++myClock).showTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">  First time output: <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">  Show myClock++:    <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">  Show ++myClock:    <span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="8-1-4-运算符重载为非成员函数"><a href="#8-1-4-运算符重载为非成员函数" class="headerlink" title="8.1.4 运算符重载为非成员函数"></a>8.1.4 运算符重载为非成员函数</h4><ul><li>有些运算符不能重载为成员函数，例如二元运算符的左操作数不是对象，或者是不能由我们重载运算符的对象</li></ul><p>运算符重载为非成员函数的规则</p><ul><li><p>函数的形参代表依自左至右次序排列的各操作数。</p></li><li><p>重载为非成员函数时</p></li><li><p>参数个数=原操作数个数（后置++、–除外）</p></li><li><p>至少应该有一个自定义类型的参数。</p></li><li><p>后置单目运算符 ++和–的重载函数，形参列表中要增加一个int，但不必写形参名。</p></li><li><p>如果在运算符的重载函数中需要操作某类对象的私有成员，可以将此函数声明为该类的友元。</p></li><li><p>双目运算符 B重载后，表达式oprd1 B oprd2 等同于operator B(oprd1,oprd2 )</p></li><li><p>前置单目运算符 B重载后，表达式 B oprd 等同于operator B(oprd )</p></li><li><p>后置单目运算符 ++和–重载后，表达式 oprd B 等同于operator B(oprd,0 )</p></li></ul><p><strong>例：重载Complex的加减法和“&lt;&lt;”运算符为非成员函数</strong></p><ul><li>将+、-（双目）重载为非成员函数，并将其声明为复数类的友元，两个操作数都是复数类的常引用。 • 将&lt;&lt;（双目）重载为非成员函数，并将其声明为复数类的友元，它的左操作数是std::ostream引用，右操作数为复数类的常引用，返回std::ostream引用，用以支持下面形式的输出：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; a &lt;&lt; b;</span><br></pre></td></tr></table></figure><p>该输出调用的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator &lt;&lt; (operator &lt;&lt; (cout, a), b);</span><br></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8_3.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>) : real(r), imag(i) &#123; &#125;  </span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="keyword">double</span> real;  <span class="comment">//复数实部</span></span><br><span class="line">    <span class="keyword">double</span> imag;  <span class="comment">//复数虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(c1.real+c2.real, c1.imag+c2.imag); </span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(c1.real-c2.real, c1.imag-c2.imag); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"("</span> &lt;&lt; c.real &lt;&lt; <span class="string">", "</span> &lt;&lt; c.imag &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    Complex c1(5, 4), c2(2, 10), c3;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c1 = "</span> &lt;&lt; c1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c2 = "</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c3 = c1 - c2;   <span class="comment">//使用重载运算符完成复数减法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c3 = c1 - c2 = "</span> &lt;&lt; c3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c3 = c1 + c2;   <span class="comment">//使用重载运算符完成复数加法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c3 = c1 + c2 = "</span> &lt;&lt; c3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-虚函数"><a href="#8-2-虚函数" class="headerlink" title="8.2 虚函数"></a>8.2 虚函数</h3><h4 id="8-2-1-虚函数"><a href="#8-2-1-虚函数" class="headerlink" title="8.2.1 虚函数"></a>8.2.1 虚函数</h4><ul><li>用virtual关键字说明的函数</li><li>虚函数是实现运行时多态性基础</li><li>C++中的虚函数是动态绑定的函数</li><li>虚函数必须是非静态的成员函数，虚函数经过派生之后，就可以实现<strong>运行过程中的多态</strong>。</li><li>一般成员函数可以是虚函数</li><li>构造函数不能是虚函数</li><li>析构函数可以是虚函数</li></ul><p><strong>一般虚函数成员</strong></p><ul><li>虚函数的声明：virtual 函数类型 函数名（形参表）;</li><li>虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。</li><li>在派生类中可以对基类中的成员函数进行覆盖。</li><li>虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的。</li></ul><p><strong>virtual 关键字</strong></p><ul><li><p>派生类可以不显式地用virtual声明虚函数，这时系统就会用以下规则来判断派生类的一个函数成员是不是虚函数：</p></li><li><ul><li>该函数是否与基类的虚函数有相同的名称、参数个数及对应参数类型；</li><li>该函数是否与基类的虚函数有相同的返回值或者满足类型兼容规则的指针、引用型的返回值；</li></ul></li><li><p>如果从名称、参数及返回值三个方面检查之后，派生类的函数满足上述条件，就会自动确定为虚函数。这时，派生类的虚函数便覆盖了基类的虚函数。</p></li><li><p>派生类中的虚函数还会隐藏基类中同名函数的所有其它重载形式。</p></li><li><p>一般习惯于在派生类的函数中也使用virtual关键字，以增加程序的可读性。</p></li></ul><h4 id="8-2-2-虚析构函数"><a href="#8-2-2-虚析构函数" class="headerlink" title="8.2.2 虚析构函数"></a>8.2.2 虚析构函数</h4><p>为什么需要虚析构函数？</p><ul><li><p>可能通过基类指针删除派生类对象；</p></li><li><p>如果你打算允许其他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），就需要让基类的析构函数成为虚函数，<strong>否则执行delete的结果是不确定的。</strong></p><h4 id="8-2-3-虚表与动态绑定"><a href="#8-2-3-虚表与动态绑定" class="headerlink" title="8.2.3 虚表与动态绑定"></a>8.2.3 虚表与动态绑定</h4></li><li><p>虚表</p></li><li><ul><li>每个多态类有一个虚表（virtual table）</li><li>虚表中有当前类的各个虚函数的入口地址</li><li>每个对象有一个指向当前类的虚表的指针（虚指针vptr）</li></ul></li><li><p>动态绑定的实现</p></li><li><ul><li>构造函数中为对象的虚指针赋值</li><li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址</li><li>通过该入口地址调用虚函数</li></ul></li></ul><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/photo/2020-10-09-103629.png" alt="image-20201009183628918"></p><h3 id="8-3-抽象类"><a href="#8-3-抽象类" class="headerlink" title="8.3 抽象类"></a>8.3 抽象类</h3><p>纯虚函数</p><ul><li><p>纯虚函数是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本，纯虚函数的声明格式为：</p><p>virtual 函数类型 函数名(参数表) = 0;</p></li><li><p>带有纯虚函数的类称为抽象类</p></li></ul><p>抽象类</p><ul><li><p>带有纯虚函数的类称为抽象类:</p><p>class 类名 { virtual 类型 函数名(参数表)=0; //其他成员…… }</p></li></ul><p>抽象类作用</p><ul><li>抽象类为抽象和设计的目的而声明</li><li>将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。</li><li>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。</li></ul><p>注意</p><ul><li>抽象类只能作为基类来使用。</li><li>不能定义抽象类的对象。</li></ul><h3 id="8-4-override与final"><a href="#8-4-override与final" class="headerlink" title="8.4 override与final"></a>8.4 override与final</h3><p>override</p><ul><li>多态行为的基础：基类声明虚函数，继承类声明一个函数覆盖该虚函数</li><li>覆盖要求： 函数签名（signatture）完全一致</li><li>函数签名包括：函数名 参数列表 const</li></ul><p><strong>显式函数覆盖</strong></p><ul><li>C++11 引入显式函数覆盖，在编译期而非运行期捕获此类错误。 - 在虚函数显式重载中运用，编译器会检查基类是否存在一虚拟函数，与派生类中带有声明override的虚拟函数，有相同的函数签名（signature）；若不存在，则会回报错误。</li></ul><p><strong>final</strong></p><ul><li><p>C++11提供的final，用来避免类被继承，或是基类的函数被改写 例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> <span class="title">final</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> Base1 &#123; &#125;; <span class="comment">// 编译错误：Base1为final，不允许被继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base2 &#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 编译错误：Base2::f 为final，不允许被覆盖 &#125;;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      关于该门网课的知识框架
    
    </summary>
    
      <category term="Tech" scheme="http://bingcs.com/categories/Tech/"/>
    
    
      <category term="C++" scheme="http://bingcs.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>My Spiritual Life</title>
    <link href="http://bingcs.com/2020/04/05/%E6%88%91%E7%9A%84%E7%B2%BE%E7%A5%9E%E7%94%9F%E6%B4%BB/"/>
    <id>http://bingcs.com/2020/04/05/我的精神生活/</id>
    <published>2020-04-05T07:45:27.000Z</published>
    <updated>2021-07-11T06:53:20.083Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong><em>2020年</em></strong></p><p><strong>1月</strong></p><ul><li><p>（书）《思考，快与慢》 丹尼尔·卡尼曼</p></li><li><p>（书）《月亮与六便士》毛姆</p></li></ul><p><strong>2月</strong></p><ul><li><p>（书）《未来简史：从智人到智神》 尤瓦尔·赫拉利</p></li><li><p>（书）《邓小平时代》  傅高义</p></li><li><p>（书）《睡眠革命》尼克·利特尔黑尔斯</p></li></ul><p><strong>3月</strong></p><ul><li><p>（书）《腾讯传1998-2016》吴晓波</p></li><li><p>（书）《Python神经网络编程》塔里克·拉希德</p></li><li><p>（书）《人生的智慧》叔本华</p></li></ul><p><strong>4月</strong></p><ul><li><p>（剧）《我是余欢水》正午阳光</p></li><li><p>（书）《如果没有明天》余耕</p></li><li><p>（书）《论中国》基辛格</p></li></ul><p><strong>5月</strong></p><ul><li><p>（影）《利刃出鞘》</p></li><li><p>（书）《中国经济2020》王德培</p></li></ul><p><strong>6月</strong></p><ul><li>（影）《暗杀》</li></ul><p><strong>7月</strong></p><ul><li><p>（游）《塞尔达传说：旷野之息》</p></li><li><p>（剧）《隐秘的角落》紫金陈</p></li><li><p>（书）《剑指offer》何海涛</p></li></ul><p><strong>8月</strong></p><ul><li>（书）《原则》瑞·达利欧</li></ul><p><strong>9月</strong></p><ul><li><p>（影）《信条》诺兰</p></li><li><p>（剧）《沉默的真相》紫金陈</p></li><li><p>（漫）《雾山五行》林魂</p></li><li><p>（书）《李光耀观天下》李光耀</p></li></ul><p><strong>10月</strong></p><ul><li><p>（书）《结构性改革》黄奇帆</p></li><li><p>（书）《贫穷的本质》阿比吉特·班纳吉 埃斯特·迪弗洛</p></li></ul><p><strong>11月</strong></p><ul><li><p>（影）《1917》</p></li><li><p>（剧）《The Undoing》(无所作为)</p></li></ul><p><strong>12月</strong></p><ul><li><p>（影）《绅士们》</p></li><li><p>（影）《电话》</p></li><li><p>（剧）《是，首相》</p></li><li><p>（剧）《弥留之国的爱丽丝》</p></li></ul><p><strong><em>2021年</em></strong></p><p><strong>1月</strong></p><ul><li>（书）《毛泽东传》罗斯·特里尔</li><li>（影）《饥饿站台》</li></ul><p><strong>2月</strong></p><ul><li>（书）《穷查理宝典》彼得·考夫曼</li><li>（剧）《山海情》</li></ul><p><strong>3月</strong></p><ul><li>（书）《非暴力沟通》马歇尔·卢森堡</li></ul><p><strong>4月</strong></p><ul><li>（书）《跃迁：从技术到管理的硅谷路径》朱赟</li></ul><p><strong>5月</strong></p><ul><li>繁忙的5月……</li></ul><p><strong>6月</strong></p><ul><li>（影）《贫民窟的百万富翁》</li><li>（剧）《爱，死亡，机器人》第二季</li><li>（剧）《九号秘事》第六季</li></ul><p><strong>7月的坑</strong></p><ul><li>TODO（书）《历史的教训》</li><li>TODO（影）《爆裂鼓手》</li></ul>]]></content>
    
    <summary type="html">
    
      记录一些看过的书/影/剧
    
    </summary>
    
      <category term="Reading&amp;Thinking" scheme="http://bingcs.com/categories/Reading-Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>20200328 尘埃落定</title>
    <link href="http://bingcs.com/2020/03/28/20200328/"/>
    <id>http://bingcs.com/2020/03/28/20200328/</id>
    <published>2020-03-27T16:23:25.000Z</published>
    <updated>2020-07-25T09:58:18.859Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>折腾半天交完港中文的巨额留位费，算是主动结束自己的申请季了。虽然下午刚交完钱晚上就戏剧性地收到NUS-ISS的面试通知，不过无论结果如何，该也不会改变自己的选择了。</p><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2020-03-27-162507.jpg" alt="61585326304_.pic"></p><p>去年2月份作出留学的决定以来，咨询过很多家中介，最终还是决定自己DIY全流程。因为GPA比较低所以在这一年里做了很多提升软实力的努力，申请台湾交换/新国大暑校/找技术实习等等，虽然不清楚这些最后都给我的申请带来各种程度的加成，不过这些经历确实给我带来了预期之外的极大收获，让我认识了很多有趣的朋友和前辈，亦是幸运的事情。</p><p>一路上遇到了许多给我极大帮助和激励的人，有素未谋面的学长学姐，也有身边的亲人朋友师长，在我焦虑迷茫的时候为我提供方向，在我迟疑纠结的时候告诉我“冲就完了”，感谢你们。曾经囿于追求所谓“更好的offer”而心神不宁，现在想来学校的Title并无法让自己坐享其成，适时接受并且务实地规划接下来的发展才是更为重要的事情。</p><p>希望一切顺利吧。</p>]]></content>
    
    <summary type="html">
    
      Finally
    
    </summary>
    
      <category term="Life" scheme="http://bingcs.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>Big Data Notes</title>
    <link href="http://bingcs.com/2020/03/24/mindmap-bigData/"/>
    <id>http://bingcs.com/2020/03/24/mindmap-bigData/</id>
    <published>2020-03-24T04:30:18.000Z</published>
    <updated>2021-01-01T04:14:01.614Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="https://tencent-hb666-1253906972.cos.ap-chengdu.myqcloud.com/2020-03-24-055730.png" alt="BigData"></p>]]></content>
    
    <summary type="html">
    
      扒出了曾经备考大数据课程期末考试的笔记
    
    </summary>
    
      <category term="Tech" scheme="http://bingcs.com/categories/Tech/"/>
    
    
      <category term="Big Data" scheme="http://bingcs.com/tags/Big-Data/"/>
    
  </entry>
  
  <entry>
    <title>20200323 碎碎念</title>
    <link href="http://bingcs.com/2020/03/23/20200323/"/>
    <id>http://bingcs.com/2020/03/23/20200323/</id>
    <published>2020-03-22T16:22:48.000Z</published>
    <updated>2020-07-25T09:58:18.863Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>从去年2月份做出了香港留学的决定以来，这一年自己经历了大大小小改变自己想法的事件，尝试跳出舒适区，申请新加坡暑期项目，申请台湾秋季交流，每一个决定其实都牵连着其他种种的考量和取舍。比如台湾交流，这一段时间里我收获了很多难得的、许多人可能都不会有过的对于那天土地的切身感受，同时我也等于放弃了考研、考公的机会，一心专注于为申请留学做准备。当然，我没有丝毫的后悔。即使是现如今仍不容忽视的香港社会问题、国际疫情原因让每一个考虑留学的中国学生都有所担忧，我也不曾为我这一年来所有的准备感到遗憾。如果风险可控，我还是会选择踏上香港这片土地。 </p><p>对于留学院校的选择，其实在这一年当中我经历了很多个阶段。我喜欢华人比较多的环境，便把眼光放在了香港和新加坡上。最开始的时候，是对自己的不自信。受困惑于我自己成绩条件的捉襟见肘，我并不奢望自己能够成功申请上香港前三的学校，当然彼时新加坡两所院校对我来说也是难上加难。看了一些申请成功案例，询问过有相关经验的学长姐之后，我觉得自己的能力能够冲刺港前三了，于是我进入了一个较为自信的阶段。问过了好几家留学中介，得到的选校建议均是建议我把港前三作为冲刺校，港理工和港城作为保底。我深知受限于留学中介的资本属性，他们会建议目标用户采取稳健的申请方式以确保其『录取率』以及利益。我没有听取他们的建议，因为彼时的我并不能很好地接受这两所学校的排名以及生源。之后的台湾和新加坡两地的求学经历更加助长了自己对于冲刺名校的期望，加上DIY申请过程中需要自己撰写华丽的言语来包装自己的经历，可以说这之后我的心态进入到一个膨胀期。2020年年初我接到港中文信息工程系愿意为我推研的信件，虽然对我来说，没有丝毫消息的港大和港科的录取会让我更开心，但CUHK的这一消息已经足够让我感到满足。我认为能力得到证明，便放开手脚申请新加坡的学校。自以为条件足够、加上曾经的新加坡国立的暑期经历能够有大的加分以弥补均分的不足，但是申请时候遇到的一个又一个条件比自己好很多的同学着实让自己心神不宁、坐立不安。伴随着漫长的等待的是一个个申请群中大佬们接连的捷报。我四处搜集着录取信息并将其与自己的条件进行对比，比自己条件好的就默默接受，学校一般但均分很好的录取案例却让自己羡慕，认为自己空有名校招牌可是成绩不够硬。我进入一段焦虑期，对于新加坡录取的过分期待让我难以满足于港中文的这个录取。我觉得自己能有更多。可是却似乎眼高手低，我的自信受到了一定程度的打击。</p><p>很快的，我意识到今年的9月份，在我刚成为硕士的时刻，我也需要面临秋招的难题了，而现阶段准备暑期实习并争取留用看似是不可多得的好选择，于是我把目光放在了暑期实习上。通过对互联网不同技术岗位的进一步了解，我开始意识到，一个光鲜亮丽的学校Title并不能为我带来太多的加成，也不能让我一劳永逸，要追求大厂的技术岗，我更应该做的是提高自己的技术能力，而非妄图用『名校毕业』来获得大厂的橄榄枝。</p><p>我开始反思，为什么我当时费尽心思追求更高更好的学校，可是却没有真正务实地考虑一下自己的职业发展？港中文难道就比新国立差很多吗？并不是的。我无非是觉得，新国立录取条件较高，身边的同学肯定也更加厉害，我喜欢这样的圈子。可是港中文的圈子就会不好么？尽管不可否认的是，去年的香港问题带来的负面影响让部分人放弃了申请香港，但这不意味着香港中文大学今年所录取的学生就是资质不够的。我也曾抱有这样的偏见，以本科学校地档次来给别人划分资质优劣，因此会觉得若我在港中文和普通本科出身的学生坐在同一个课堂，是一件让自己受挫的事情。现在看来，这些想法未免太幼稚。这两天我渐渐想通了，当我有着明晰的职业规划并且制定切实可行的计划去实现它的时候，似乎其他的就显得不那么重要了。我可以放下曾经的偏见和所谓的身段，把眼光放在未来，而非顶着985学校的光环而固步自封。学校title能给自己自信，但大多时候这种自信却只是虚荣罢了。我再一次为港中文的录取感到满足了，因为我清楚香港留学和我近阶段的职业规划（base深圳的互联网大厂）是相辅相成的，我也能坦然接受之后可能遇到的同学，无论他们来自什么样的本科学校，这都没那么重要了。我的许多好朋友，他们并非好学校出身，但是他们务实进取、勤劳善良，我很喜欢他们，也乐意同他们交谈。而我将会遇到的硕士班的同学，他们大体也该是这样的。学校出身能决定的事情不少，而其不能决定的事情却更多。在很长的一段时间里我曾经被唯名校论所捆绑，认为对于自己而言，只有最顶尖的名校才能够让我实现所谓的自身价值。但是我清楚现在及以后的时间里，我会摒除这样的想法，把眼光放长远，务实地规划自己的职业发展，同时也学会接纳和包容。</p><p>2020年3月23日深夜</p>]]></content>
    
    <summary type="html">
    
      The answer is blowing in the wind.
    
    </summary>
    
      <category term="Life" scheme="http://bingcs.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>About WeRead</title>
    <link href="http://bingcs.com/2020/03/18/aboutWeRead/"/>
    <id>http://bingcs.com/2020/03/18/aboutWeRead/</id>
    <published>2020-03-18T09:21:55.000Z</published>
    <updated>2020-07-25T09:58:18.868Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>本年度至今使用体验最佳、粘性最高的应用软件：微信读书。</p><p>谈点个人的理解：用做游戏or社交软件的思路去做一个读书软件，腾讯的产品能力真的很强大。</p><p>打游戏为什么上瘾？短时间内正向激励频繁。用户粘性怎么来？刷级，装备，成就积累。微信读书有什么？记录用户看书时长，总时长以及每周时长，每周进行好友排行。在大众文化水平逐渐提高的当下，一个读书读得多、书的品质高的人，是不是会让人发自内心有所欣赏？尤其是在高知识水平用户的身上，简直一拿一个准。这其中“阅读时长”就好像是游戏里的等级，打开软件开始阅读就能刷级，也没有什么人民币玩家欺负普通玩家的剧情，对每个阅读者都是公平的，刷级的手段只有一个：阅读。用户粘性怎么积累？看了多少小时，读了多少书，全部都是可见的，这不就是游戏里的“勋章”或者“成就”吗？</p><p>什么？你觉得阅读本身是一件无聊的事情，“我不喜欢读书啊，我的朋友们也都不怎么读书，那些排名什么的对我来说没有意义。腾讯哪里发展我这个用户？”。那或许你就不是腾讯的key target。读书时长排名这种手段，就是把手伸向那些对于自身所呈现的社交属性有一定高要求的用户。读书时长多≈喜欢阅读≈有耐心≈靠谱的办事能力。无需耗费口水和社交手段，直接通过静静地阅读，一边增长见识一边把个人魅力值提上去。</p><p>当其他阅读软件还在考虑用户下沉的时候，腾讯已经用丰富的产品经验，把手伸向了对社交属性有较高需求的潜在高级用户所在的市场。</p><p>你把微信读书当做读书软件，腾讯把他当一个社交软件在做。</p><p>你以为他在第一层，其实他在第三层。</p>]]></content>
    
    <summary type="html">
    
      我谈 微信读书
    
    </summary>
    
      <category term="Reading&amp;Thinking" scheme="http://bingcs.com/categories/Reading-Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>读书笔记-《睡眠革命》</title>
    <link href="http://bingcs.com/2020/02/19/Notes-%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD/"/>
    <id>http://bingcs.com/2020/02/19/Notes-睡眠革命/</id>
    <published>2020-02-19T07:20:09.000Z</published>
    <updated>2021-01-01T04:10:20.935Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="昼夜节律：智慧睡眠的7个要点"><a href="#昼夜节律：智慧睡眠的7个要点" class="headerlink" title="昼夜节律：智慧睡眠的7个要点"></a>昼夜节律：智慧睡眠的7个要点</h2><ol><li><p>走到户外，让日光调整生物钟</p></li><li><p>花时间了解昼夜节律以及它如何影响你的生活</p></li><li><p>了解自身各项高峰低谷数值，监控自然而然的变化</p></li><li><p>睡眠质量最高的时间在凌晨2-3点</p></li><li><p>早上放慢速度，不要陷入一团乱</p></li><li><p>晚上多用红光/黄光，少蓝光</p></li><li><p>想象身处岛屿的作息，做出简单的改变</p></li></ol><h2 id="睡眠类型：智慧睡眠的7个要点"><a href="#睡眠类型：智慧睡眠的7个要点" class="headerlink" title="睡眠类型：智慧睡眠的7个要点"></a>睡眠类型：智慧睡眠的7个要点</h2><ol><li><p>了解自己(和亲友)的睡眠类型</p></li><li><p>规划一天的日程，在状态最佳时做最重要的工作</p></li><li><p>把咖啡因作为高效的表现增强剂，而非习惯</p></li><li><p>周末不要睡懒觉，以克服社交时差</p></li><li><p>办公场所配备日光灯以提高敏感度和工作效率，改善工作情绪</p></li><li><p>知道何时该做什么</p></li><li><p>和伴侣彼此协调和适应</p></li></ol><h2 id="睡眠周期：智慧睡眠的7个要点"><a href="#睡眠周期：智慧睡眠的7个要点" class="headerlink" title="睡眠周期：智慧睡眠的7个要点"></a>睡眠周期：智慧睡眠的7个要点</h2><ol><li><p>设置固定的起床时间</p></li><li><p>用90分钟的睡眠周期衡量睡眠，而非小时数</p></li><li><p>入睡时间取决于起床时间，自行推算</p></li><li><p>考虑一周的睡眠周期，而非一天</p></li><li><p>避免连续三晚睡眠不足</p></li><li><p>试着了解自己需要多少睡眠周期</p></li><li><p>争取每周4晚能够完成理想睡眠</p></li></ol><h2 id="睡眠前后的例行程序：智慧睡眠的7个要点"><a href="#睡眠前后的例行程序：智慧睡眠的7个要点" class="headerlink" title="睡眠前后的例行程序：智慧睡眠的7个要点"></a>睡眠前后的例行程序：智慧睡眠的7个要点</h2><ol><li><p>这很重要，影响睡眠的质量和清醒的一天</p></li><li><p>日间偶尔脱离电子设备，以此为犒劳</p></li><li><p>睡眠后例行程序很重要，不要放弃</p></li><li><p>不要在头脑不清醒的时候发消息，比如一大早</p></li><li><p>温水浴，凉爽的睡眠环境，无论冬夏</p></li><li><p>就寝之前放空大脑，下载自己这一天</p></li><li><p>睡眠前例行程序，用于结束一天：鼻子呼吸、放松心情、光线过渡；睡眠后例行程序，用于开启一天</p></li></ol>]]></content>
    
    <summary type="html">
    
      Nick Littlehales
    
    </summary>
    
      <category term="Reading&amp;Thinking" scheme="http://bingcs.com/categories/Reading-Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="http://bingcs.com/2020/01/28/happybirthdayguan/"/>
    <id>http://bingcs.com/2020/01/28/happybirthdayguan/</id>
    <published>2020-01-27T16:00:01.000Z</published>
    <updated>2020-09-30T01:36:15.195Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1+UUEnIqKZvZNXFTrt+FBcyKG9TiVFv1ls2x5VuZiCQ4sN+RIfif3qN5fyfy3gq21z4F8HQpAhNDDlpvyL9JFlRCcd8vX+5/gdrLqp3m7t6YcGXsKt2xu5XrUGRk1Idw32KU5gnjB4M9nWD5qNT2w47F7e0c3fmVk9FEwexTwNn1OyrNcU6AdnLC2OpABdD9nbnquqmSw8k19eq8f37Wtw22oZzhzbF1RTQAdMSew3MzaKPiPetq5Zx6E5dOOJsqIgKhCfaujLh0JUUNAxfFMCEocvJKMqH0Cg++vXTXUY86Erjsz+vsTv3zrXwIT3/sqy6oh/UEhoBgAh+6EHkInBAaqIIURyBcOxkOldWACKCVEVfnk4N58Ode79F06RQAA/PWF9svIAB++Lgc/WV3Ojpck84KGJrxZGzttKnGJ9W6ZWvGbtcX/NvmoyIDQeJeVgGyVANEnWPKDn7KDTyA8dV8WTvZDu5QHHC0i5qeQlYQkL1v+TlCPkvyE/M7XdWfsrgNvhXeWif8/7aXtpy3h92jV17ahX/aSrrVq1fbOZTv4UOVYsu88cSgF4wzw8D+Of3u6+N44h0eUxNNlkG+V0+eKkurjMPJDKXkF9sF9J0YP14yN3fC+nhI1GaONBAApmvEOEeXpGBvO8jgxp1H+saShvq4+COca0mywmp2yNGs9fj1tHJLlMi0zU0HRF44wQSPN21K3OGvGedsR5CXyPevDtKXHwdsVkUFIh/Ar3b5+wpf8B/yxEaGA5l97Pfm03EhpO3BYhunh4rhnRqknPFzDyhGO7Kv9XmjudVgH6ZmJPPHGnG+nJFDOGH4KWnHLKp5mbDT6LrwerJ5Zm68AB/WCkAdbvrAjSqV1fjIjqD5LPw0F2o2JPlfVLDMgwRq6rhhTFyiVBMDAdhAE3eU0nwTrFVTepDdfvxYZlb6KfLdZIG41kjyigvluJr2NsQE+q1SjZrrK8GTXTmehQOXIJuP4YeVExL05wM45qACH/M4nF893Vhdukkg7R444qgcezal4W248HKjbeOr+1fZafycxptBVdTOp6JpreXCqMiwc7udtu7UZOdMYvDCSBwh9B71Dyy8PLgboFZUJhpGJVPxobHGQnIPJJWeEFTWr0KvR8yuaDqJT/SiCyn0C81RGpYwofIltQHHoSqINbQRfe0vAnGV9iNs1unstTsaLBfMBJ5CS1K4ZMtFAgKLOBB5DegBe1z+Yn5y/JOcx0fVCCBhnpRK8Z+yUjbK2fZZcDHRIQEV7BBiQi4xJoU87iU4hFZqPNKu/ME1AkxjTRpOyi5h6g9qQT/Yyd+KoNw3FCYdMNb7ckrokTCqUFmXnYY3ZSGcr7OtoQDKo3c5BwBxEyF9x4CsEO8zNhN6vVuoCF0pWdeHMGn8pQtWF9daNW0m/vAS3nm3doon/LZGMxjdpVMlpVLYgIQgFJzwqlGp267TRXliUP7SE6BzyiFaJt3soFlJpMTJYYkk9nFsRfS78/UpHhZyFsQRT8IFPxPb9l9U3oOY0MzIbN/n88dWEeeXfqNpTmqfRL79Yc0D80VHIdU80B8hqDtCFQXiZB28r1J61yqWh0GgTR8evELRYkWX9AaDVv3iUtp1HhYFzV4oc6W7ka5iD4K4SIrXtgqecIfpxN7wODXA6zVYEroFaA5DyXpNL7V+oZIFLOULhcsSp6+636Y7CsvQD/yBMjQT1Ey4ZGa2DrB3UtjeSsXOQkSxSiDyYuEWBduAonn69MzMN0kakyGsob8Cm06lUdnw4Pe35dTv+A55EstbNsFc5HgSGbAUbhjvvkdASxuGrn79x696xHjUqe5YRzqVk7Wde6PnOswVIJRcVWVvZkw2JMNH33ma8+btSkSXZgrDMhOoBOdAAj+ADOYuFrHZw9B0KiQAwjDXab/E56scgJaR1N5Fx33lAivUpvvney96iZSnyAh/Ry2hcSXcZfMF9hrsRzSlv2jwlH5gN6DnEWe5t8HMCiDqU/ktq6tKcK+9ZHOOAf2ScWvQ/V1NI78mxmWhHdTNz5LrTybFVfCbniPRAjBdjYTxNq2C3lG7+MUD9FRpBg6eSNsWb/SWSSHWB6PKLxXO5t+3NGbJbbY2zk38R6ThuMs7lNcPn9A6CSeH0nJNYllvnH+Cb/Kt93TmDDeb5/TrLjGfXtuWOH7+2mtlUip5perwM9wTyOuyCRixFqSf2UBkOqJjL0kzqwCuMpLCV66U5fXWhb4/3lBIT/EyJZRm4mhWtQt3HcPAuJVJNMt6nqBUGCMEo5aQfClr6E5tIHJjPCxc248EhNwZpeiLyleN10zEFCmk4IEDVSLNoTQsZXMwalud4yd2vy1u5Rryt3GvJhVpaw3a14ovKZlW1GBonJ6kD2JtvPLrYRzbr6aycXr68B3KM/k05KbAiRpLjVVMW59n3o7Boa8iulBzoDd3iLUP0FIzQgfyd1iH5ZTeNh3BUf5utHcbzV4WoqsjOGlkwN7AcvidJm7WqVe2SUT/x81AQVPrWc+vAH/glZEFCu5jKPf1oYQp/eREO8BpT0gwiZ1MZD8B1HYBZfIfaGJ8U/TcJ8sGZZlG7rTLKYj3Lqu4fGjHkfPyaSHkk/0vFD9pzchbyZN14px/H2pnLm+y8CrNcr/GtFFXQmD+BO23j30kQOjxaQgoh7r3Uc9ysstoAjnK5TF40lRy75ngfMtmAr/dU5mzZeZGSiId04I3bJz6AMmy7FGE8mh4VBCBdah635SzvzchPQyCowwEs2zvoR8Lur4xZJ/H/Hqg9RjOYSjGI97hGFxbUCXIg4ekf5HLBUm9+C+VWq7raB8URMSr6lzqod4BFOs25dReAeU+Im8IAfHAkm3wwAVBLsFA/+2o45glqOtNxaVAOZy4Brc5ol0pgcLhWMzDMJCU6c7VORXoJVS2JXG2BpLwleKLvtCyupH3HxTbTadJL5fgncxhECsgGpSLRnKv8AJNuWIj566Lrus6oADXOATTwX46REVWDCF4A4QWEQJlr6hglcCf7HU/RwUJD8TS4/3PIPHaFASK0zTaKRWp/jBIamZZ3Bz/BhX90Ld1XPQL6I2p8WyidlCL/86uIiAQ5MbjO88x1LtCiA6BAN0qHDrCoguLpSgs0G5wf/Jh2kiiwZ5lc+q13IzERaCJIGTebBqW8DGgUveQxnuSEaPjwGX6yE+SFyQXybdWwTh4pUQr2dZjnb8kTQq1/wH7hSXEhYb+XppQFGf9ZMDhh2jZSit+CeHgh4yzFffof1KDPwb4kAAm6jvDe6yT0uxDzPJ4GI1P1BrO0wVJ8tmDbyrSefcrDxD9PfBI+GrMOJUQOiaa+nUNlZSzhKmRRr9bpWun9OFPXUBSFs765QNIxGzEdC8+8wk1EVr1qjfyH5PYDa5huQyqNHHdR/OxVjNiDUJxc5LDrtgi3ho7F0z8TKq8gMMXjmXfVTn8Mvce8WfTPgaBmyKeFnB+Xfi7zmz7kuq/9LbgR4F6GhBmg25iYIQ2tLqWGz8uMe/PNO4vSCs4OWACt620knUokCaRXX+i0Lacol7rHszNx14pf0QywboDOnlgz8uN2e5mGQDAy9EtjItzP68z2QJCThCpPS7E5ymFQyekEHoBrWrsQm1sPdkB9v4xv3WPFXuZpD0PxZao53O767C6F5bLUTfjduxpNQc5zyJwWneVg7NX0nI9ry9gefjnsMGhAEfhQ4s92enfkaZFuGE4KbHKwO46cszWcmP337MJBJoYTQ3n8JAyDFywHz2gPZV0/uJQaW/4hZCpBe++yjRAqJezsOLxnPVdyQOGY2wyUHrQT9eLK8fRRSjR2hSIKXDSVwXmP35HXp1yN63TJbO+EKvZ180J8in+8tDE5NQGthIq4bk3RytE3h4+pkcevjvrx2rPjW5NL570vY1YmMs7gBhIyxd0NFOZ6Leyji9VBJ60FlfK18Ld1+ivHyGUEMHFx8ZcREI16UyiWKCyznlz5e5Vh5w16fU5V+uXKW0xEbZ3ENUvdJNcbBJKz/B8yXPSfOA8mFW2cMFCdLKRPdqxwAZNpX2/JXZnLDRNuJUZ/JSKnE6J5W4pQvN16FyuJRWATA1nPogDsxxLyVdt9lUctWrdZ+2zzpE4p+TgYRjLxtU2roLKWidStzC0llJx0UxGguixwhOWO7qVYm19qcnuW/ztIyrNr/kOysxIFP6dqFXm3sNtcHVKHSlK2JsNgx4nlSI98VZWhwh9P+KL42JfXklt3IcBGrmhwao7bPzuUbscfGZLQ/Kk3/lJ7O0AY/2iSCpTS2OMFAAdzeDOSa/K/d725wIN9KN/oGGKXoL6GfaM9DvXqZZQurVCUobLex13laocObRV7VC5k56pnL+DIf+UgNqJnzZ+UFyfYvBuxrI/ETf23wYOVWAP3LDnD/McV+63AtKgep5Hyl/YR99vMqqjHmsWyVixAwQFLRO9zAk/vEDTTmC6JCTyx9TkYrk3DPgWJxLtkkelMWAdVbD05FGZ/9D05JN5AaetQKJdgncHfD2MOC9NHMu3CBjm+xhpCrO/b/4lL1CVaCCKjlyOW50Y7PlV0iR/DnRA8diprWvsFt81l1UexATfgr2IJV9TCEsVXDbScu5ngFloAx98wefFFa732m+OqOdcjDtZS7lxPyrIih6KX00MBbunKH0KuRwyXoSu5AaRByvxc+QvzNM/0rRTYYr1sMVuIeUgNmfYDrAPhDjT3cKejXIqlQ4vJszLw/g3ESBIyfuk0ajQllhQA+kyh9Yus30cnOxBxazhZXMswB83IK/BnIQlVToyM4/RE99ntSPazCCHctSZggMOsYVxE1mVsneM/M2+jayd3tnF3O2+WXRT7vOj+jzMsL+yhn8sKeXYdjADDpsGD6gGVVRAHs/yq9cI4pqWCOmeyX4RSvZwgv5V66RkFlLQjK45uitj2fFjXYKNunaASapLgBdy8ejUsIMU5+OEm3vqOihlnfCSZuKyoy79XZpNOo/xXNmwnN1wBZZamA1auwX6THislnL2aT8mwe/RznaX45af7E9Xd35g1fYaLSUhNdTtbGIaEiKcrMsCyLB/UqYVohOjphERjacGgQvXa1D0l2ux3Tncpc1oEwwbT+6TNHaSW2b6PAcx8smMICVAFPo8+iE3ezomDmoTjiU1h0XVmOu9wih5AJbxBejz//XAODhs4neaz8J8B5EASvVgnloUrDzOaWyPsQoVoLabUEDsc1VNyc+59COG9xpRVNj4OhI6TlF2ZfEaVmwcIVHGGF9l9BtzkHNHtNAFmxvbuV8avHC06Iq8PrkjiPwPbeEvoU2ZLwEOhbnhqxxSUm3ABw6AUJntpo1Nkt9DS71GPC1E6l+aZMUwrC1O+ZCzUZ/zeBBgYPpzWegx9Trh2leqSY1vQZuL8c4AZONCtUKxqBEmEXlRfsOXJaq7+L5vCoYg0GC+Y2Pf+of3qcENtLgRCtRTVDLZf0JxAnaUMVZ2TNctRqbfXuIkp5Gz71Xtl2hL9uhEvp7GsT8SZFj6X5u59XtCgdqpYTESakPLcZiw9Camqzr9cBB9TGngjH6mC6c4+VcWCQOwhCZZpFxBzd/tSot85iesKdd9nk9rbwTpClEKTJgQvVlEgp31s3NxZ2pzcY/1PfpMut3Nr4NQQEVj3zLJNBh+k1MrwVRqns4P8yBBTkcmmR9VR3QkAVvX4aQSWwgoTmTmsF1MH1k3hqSGfHGUZHixYCUB5+FBiPnPLyAV+3MwcWsGr27uH+rWwdgWoF95AqGXBlaeBg4XpktUwVJ6wR0sZ14KUn3h+Hr3OYdII8TrJgn24opGcgwSukzk6+b/h8wJz6YYnHsJJm/IDPm9DzFKyb0cZKaqo0Wf78rMn6H5rnX1lR9Vx9E4AFOV4Vfv4UZURLVMBcOfLOYnX7HT2Nq7kJUBsMc6rZuyVhZB8d6/nGD6GbQPMQc/8aGtNs2CHJ+ht9xBVjZfhAsfMAHjEqhCCOFtPtLoNl4f1MuanAL9I7V9UUHxH6fLNnyFgtEsy4RYvl9znGyWxg5Ux3yNWtQhZtivaUaKYKapUI1o63QDWaG6RRRnN8wE2zhcpfWEjP1dto751oavkSSAXPT7iA1u7MOY09X66X7xDdsnk6i8j8+fzmSXsxPHPLKmaPQSOKGJusqCmeMm0kahZRC46+j88pVYrPErop7a1YRq2vO0mLjkKckt8lhfshwYJ2tMVPRyllqTMJSjxYNUS+07BPkf6IyoWub3GgkrELPiD4NVpFqf0O+jNl488JMGUawSHuvvud+Q5cMF0RFod7cFEQbCpUjD8r2pslfeSPGr4JqWX7fG6Vf9T2vGznlXypPbWAzcP81O5xTOedHT62pTltl7sHhmmTCO9y0AuTXMdy4ppvMQw0IhmnmvDpZewO4S9F8H+J4yGhweztX2d94R3mFDC9QAo960PsOkiGed1eTRcKkGedbJ5LZg3OCzomjQcMPxGZVw4sNDpi2bustdsMSri3QSi1F9uyBgDBlUdQKxlUqUbJ89ADTOozmyKq8A2TL7+wrrEXWShU8a+BwJjj3nOSt+5UFIjH45OgkUaRd9xlN4/64TIKSMLdlFm6E7XKUQVgOkiDBFeal8/BeN7RmM2UuB4JFLIbL67PLsuB5DO3qkcHCnBsO9esEXmyJ3L861ypL2DhcqA26wciut1/ha/vVJQNdDJ94b1E2EfPjGcIHWdYrYVdAktDiZBsoV0VEExwAkBhOUEcEUjaVuabepAStM2jjgUi4uKkc3mwxOaweOBzfJ8oyy/F1uH+HiuGS3KxKB5Nhqyx84gJzFrFmFC3mCbt7Yq+TKZqgJ7JVcME5+jiDiKXpaC5XrqwkAGG/QDBjImImocT8A2T2X9VgSxccXP7BgTxrb6RZF+tA55cgCcSGewHSxa/BcVov5yT0VZp4uOyAy9ZzZ/M/x6a3uby6go6mmp4L/GeMT4/OKmvH/Jx2BI0EvQoT1Tcv47EXbYjyYSOsV4pqF3EiMIkjX4I2cIkIknaq7/6yfZd8jKpj9tfTBWtS9FN3d4cr5tMuPasQa0nGLqLMQ7TBNuPYlikJrVYVGbO9HEjT05+AC06CBNskdRsJWWUOyuADy3Vu4OKVJ1W8bLbK+V6JjToGFaNP1xVNdWZT/Q/v1TLrnKPLRyZBvfaMhW4/h8FHQ1ReUrcjDZWvEeK604tmxw2IrbuSQs5z5VhlS0ST2+RayAVDgXdBN1eFrI7uDCMpglcvbNhGoLA0ll4bcTbJLUgq4et7goIa2kG2X9ZMxpxqmEgpWVutk0g+IO1Ujf9o3DdFqGjSzqZPINAlNoqtZfsedd/9FWzINE7V0X9Ppfwtp7qONOSyppROtRasiQZmGMTsWdBJ4uzAtOB8A/0GtuBChp4Iy5Y2qnT3u5P+2Q/TMxJYD5cX4rETdJtaKt2zl0u+ywJfYcTFtWc2O9f9bMNl06cSRhGLIkFNa4cEkn7MrUOB4Aiy5oZ92JI3uZVdzDCUV8Gv/Ms9nHrfHTyWBIGxyyiqGboLIL/jyIdQLrSQs0sEjY1SEds8pS0ALQnsnIoK4wvxa7x2hNns+d6T1JkaC8oN6EpOA/KaHQBpgPAb1VCuqxsFZqr0iIOEaZE+01QgFTcybyaiAgNfgejUM+uaLh9kMql5Nqx/vqA1x2yhnSYq1Y8coK1Snl/YWihn+WeQncojCUTXzaMs+k0Y+9Yd9E3BCLUmkamzYATEvFLm/ELR4smQFiZ/rjaI6YM+T1VOBtaTmg7haXVGdSz3cZVccKuC5c1ksX8c5Gxa59vKhLWMjauuQnmKBaPZpvVrLVXdjENmYTQ5QIphx1MIP1GL6UE3oCwWwhhmIciaMhhDVlCGuKDsk4debiU7vdawQUeSbOsbSlsymWRuMXlZYv0+Cvs3VjCcn0RH16UdCYLIfVk5K72NDCtVhIJDrQSRDsBfax9Y4ocTo8nSMbPGLKIdE4gmmD9w9rlDewBqB6Q2p0PCtIUTv8T7u/1HzqRHieGzdn1gJmKV+s9Igg3pYtdSKCAwH3APycA/NmUllCB0RBqk6sTKiEa+DAN2zVcDVacXU/5qztwkcY7TiZyiOaXv+e5OT8Jybg9YUOnY73kh5ZEQJGpOquEkQba89DRYLN/UhRWwJIHZ89gtA0RPRbx5XJoiPcp1epos1FccPf31ltDTos4g3DovYMYSewyd1H138zOWjn4vn5ZTaT/sR1AwBEJi/EWM9+EEkIG+NsD8adGARtwur3hHD419g40RDh88pPrkRbHJDgUkEvDA6J/C/h26TpB+esQO5AWTNn5Xst4Y/eCre+bNueuDqKdOMVnOBpsZHjTBPW9NAJuype8IjoLVy8Whv335Li9Xls7FKXxTnpKrcgtvk6tXd0ZnyDQJ0w8nZgSr1q/m8yTiCzrCi9KIXI01eMLRPWDQQ9R8NxkV8lz9od1VVe+YClczdDLlr48vyoeW+8dhmWCUqc6ptLc9+3d1SQdUC0kgtd/APr2nxZc+JOBOeYi4FFpMA2ghp20Jbpxtf2EYUkIkASHwPpZ9aPz/qEwXw0m79btF9cmza/4CS6Qqvw7Ekdz7xC09Uy2la+tnabesOCne84kINvomtPXDj0vg9y4GGdTncCHlQpBlpVbETlmVcOW52157BH0hRSiFFJ9eF9xTTgDVeCop1dot6ihTdwGvXEdGN4SRKunJeOeavbEUb30KqBf10+7T2F+h3nrTOB9A7jyuVdDo2Rmzc2ceOStyCF9MoBk/iFUmnZZvYPOZ4Tb6ml65IBnDwJ6DY/WjPmtxNezaokJdCUVXnZO+P/fJef6zDh9j8cubeOnG6NfQ1gXM3ZckHjuZAQhl+sViTNVSx4wdXzDiz39cAj0QstCW3VWPXxzT/YIgRFcn1ml25dCDeZT9LYrXr8FtPFPH3EeCicBmxh2ccuWWT/XioYxqBzdosa2fYvdZZZEZoTZ8K/D2mtjlfs2jj76fQ11r1yM8Euzuv/X/lWvn94nBFHXq9c0sPF4luk8Ru16sVPgvGTTa+amti5rAinFDi5nZrJyGyyi2hkOJyitTaAy9/J3F14o47Yi+fHuqScsOSctZB+tXda+PDgCttqttNHxNWfweYYKi/Rwzq0TU6HxOYcT/G/03UBMUBCdV4IQcgo881gh1k05JUeEV1XtghiY1E2ZDRsaMlGaOGpI725Z4iUaKCfVVOUuwLsm511lC3Z7KW8QMHsksx8zS55c7tU6SKYPsSZtQGBP3tJ9kcDMDtf1MWi3u6kC1o1oslGkWGue0Q75cbkAabPziwAf3Sb2kup0kBM1rCXZptNUuKSZ3nK4ezROiyJYxBUaNnWRyV2wdIxI3BPIMgzrdt0bDDwylCPnoB+5bwy+rdMTsI5GMIQ1gszFmZuI7dYhz4lwIzrAsk2Gd+qEK0rTT3rL1L26ag9lU7/ZyniR7X307LPhi5qIpV8NuhdZsdUWK5+iS1pQ4GrzM3D9zeTc6s89mODphCt7g7kYQW9IAghOdGXJSNo5ZDAhGjKZa74kUZ9/i/+nd3CGWqsfhIZmwNbknVOuBgbpLm020ggBpq0a6CM79jJ625AtM2FumpIJ5CXvlCc+Ms8TJHgvZVGzWpBAoyRUYdA0O4Bx+KjCtnh9jQAVBOgyoVwQKWtg3XaHPuYeaE3knEibka9zRwZyqpcGJxXnSxKZY7HlEl25NmotrGRRpSH10AJwXCSi83DrokhAJCNkX48h/Z5A98FjcZrCxxaAvcqSsM/IdZOcMBRdDcfQL23xCml44q8X8FK1LaG7bjKVMJq1EE2/DPOVnjhez/TcO2npfg3He7+oT179978aV9NeDa2dSkhqQW9BD8iUbYDaFR4sBcny+7mckT0t6o2dguIRdXnGy9e8wJbMooYtpO1GDgBi7tXLZhScNE396Vat9WHC8pkSOMgQtPqxHqW5TbXV+/wxFf68yBMtbx26waIKl8gRxIqJi0AcW9+Hhx2Vj6sxphEi7KpH4faiHGiYrTFwgx29NbdLZidig7J66v5A2I1EApe6987wVcGNbyQYonVYipxs4PcV/2cxtPqM4OaQVxaYcavksjIUJOwpXsvRrPB0AxFiHn2KtAeZomwWxseb5c7oW04410y55Jgr6IUA7OD0cQVxC+1F8S5mAgrLDbpPIB3znhgbRe0tUNV3mNiFE1VxA7Vb+wXafsEaOC9CRyCJj3rLf3aQoLHwQTMQU3//G3TaQH3NQfNVwvOTIlC6nVPt16hsfO6sMocmBXQ9NGc/auWbZXzpkuO+cqu5QvWIz4qnPoJwneAMGRg0yGrenNjAsXcOzUw+FJxlLoYQkF1riqhUlsGV0Z4Jlcwrbovw6/wnifJQZiRY6/m9rK6lI77QreBpkjEGYoSar6Y1JVTAPZYI9KgTuPKEymQtZFADfw2z74SIIgQbK1ionM8dT6Xi2h8KL/+KMZh4aM9uj7I3IJXKbjATIYCdcNLkreQRhRB3CcYrAIPb0oNJa2fFaXLNEZM9ZKNylubn07xG07kJnPe8d4TvatSFSF8AFZQP6WGD3D1kgTkfP6uQ/Xe5GJPrpdRjGD/LiMBLK6ywJbv7jiqhhAqg9Ixz3yFNNEeAq9oJ7AVJPHCDH5isyPrgpjffYgJZAcDNm1YVzPXto+MDwGAuO6Uwf6nZ0eL9x17KJTPbaNMPeCI27zwVpiy/9SlqyU5z6euAxU0FYUDTpa6Menz0vSiyaeOn/lZYisYDj3uNoazMtH6mX+HY5+1mgkOoeNUwH3zp2CSy8pALaqdkqz5h2IHv6yrcO+aqfTlHGjdpEDnj/1tttOcR2TP1KEdAYd7EvAoDry9UnU09oFqC/jfnZP2aBLOtFtzySVI136R9/P1bopSkEqPdgAAjxo1d55XRnYJagX50xrkKt1ds1C4XojXifKJgHQmWas1Mgtgs6CYWuTSX2dhu22B0qAkcBM4sDX8nTOcJ9Bq4GWPxm7tH1paHQj07HElLmLNOL44jVG4EY+7M8SWDUZhUDRDSBqodOGXRZeq9da5SU5Jl1m039qE0arfcXgWPHW9Hx6iveEEdgqbe675b0sj4HxyPax790AZgHZHAmQOx0XMeyUqaGG1j4eI1RIEyQN8hyuEii4mYHRGI0+pQ0HKj9D76wnZbChfvYLZs1tiNxMtVidF+egcOKjBB6lF9b44uZv4Xq7w5/7Y0v/MmTW2ECkBiGFnY/phDYU7O6UIVuFIND/i4ju2oSOe/3k4OLc408k3gXdQlmdF6vSgfYHiAu//EyPzqQJjcyTqtPgqNl86Xe88gjoVuUtaGzkovtnZK7qF17HkCrYKvI/UCw1ee8QZPnPr1lnG3J1Fsu6M/zeSf9BC/EusCUaUPWIttGDvbozeua6Hlw7z96Qru/wDd8sLIL3jXCYIfLOFChPyVPXgScYE1L5Qt62vDgD6PqR2ZvIEDG7+IvkFnwLjxiXSdBrnMNsDpD3n07sqwOgyjkYSexwGzO3Pw2UvcfukiaTzmTiSzWdWImIGbahGLwMD8wnhAjXvdWO5nTs6jcdm9Vs7fJBdPxc/ADyYZw3/KKa9RywhMm6PZcwHa8z937EAmWllV/tp2K2iQ+GFyj9Vx0ixpBrI5MmFpEshwfrjKOeJSjaj5DiUXdJnyesatt3eCVb0uYe2n/5vJlqzruMXT1kvlo1njwgCmXnG91epcMXoJVtbQQ4pO38YNoeO3Osvc9om0XT5HJ3GTX0ZGfi0VtY3BPtcBLmakFSiz1zITiLknSpS+uVBIAXllh4NPGyFOfmX4AgqMM+aEycyFkTV/qCz7kVFUMCORZPmK/OmxVQal9/RK/5A5y9SEP4oq67e7ppW2RXoV1YiI5mvKnXeh5E5zA3qFr/bWq45S6WmxnMCCKnOp6lGEcmR3uO55g9BfwH7Usycooajwoxr62mantNoZFQTX7PazfXcOa77rBmw92K4/vvEZ+VcjhsgcgkjDZyeOk3COm+iPYzNmyXzJ0pfv7yrGlvnaT7fFLJeHcd7+7MPJr10JAS7eeg4usUl8chU+g0PpQCUqABAt5XVnOUSMf8SneWygAZ2JtHzvGuaQpzSzQAaRxzIRuSAHe+iQm6gz7iICYy7sIVSMODQS39qv8KQJcjHyF83KCIcZrQ1svLAg8CSRP5pxi3dp1NUA79NzGE5drPBDQR/z2ve903QdQ11XJfSUL/IZZi/yRU9C9KOenoDwsk/S0zs22ZfEP/K4Xw4RQDjlvN0/xqR92+xLJmAZIwKEBDn/0ZMgX6hY5g2YOgI9a8nsUBF90dAcBismjRYCoVJ1OSoUFVh4CcgIbYMGY0loqfFVfbI3cg0aVxeDZUsSNaZlCub8r8wKKE28AM9/864QythqmikChksCpbJJUvXMpCOsojwF+Id9mF07RZhunZc9qw50WgVhd6H4dV27mdEiWfXWToxiVfIyAW22GcxojV9ueYj16/EwBjM3UFwIP1mXRlolezt2M/HOoTD4tAa5hfRZxR9ydmgvwypVyx3o+TOzbFGGIXuwaCtV9U36FgkShrMM7sRn8SIL+6bKkUXzXJowKceCx8xqU25NA9/7M5AsmWAxwWfsa3G+bN69E6nZyGjbCGAaONzFPXNcBooJX54gdaD6Dpzd+dSe/9LqKZz11jphG1l9Wtx7jgArCtvXKWn6unCleDXb03votlK62i7PO0jIpvUUqi82Zc+zygWVhSB0TnAslmCslzB/Lw6pnmyx548+WBOIjUNkC8/FgxiK3oB4ptnFapNTQbWfb8nLs9KeXxgB7tdmUFaPMJBIxWJ56EwToYk+dGsKoRYTRKtFmFK811v/dOFLBZUR1wFwB5EuQcug/9yXCYhBd42U908zNblm6f+0Hw8yQyuZycSEFEXSNz78WyK6wC9Jf9xuT0+SD+UEdRu29RZ5M04cKzytGd8ReYue739cCDsZq3hW6x4HotSVk/LZf+WstwI6bjHnwm9SOtb4oLh9wrlYpeYALZz9ZSUxGtpouUbsbVqENbM1ARjnTjNhf2rRCZe0t8CGCSJ+c+dBpNY6bCDQVACv0Bw4gKbvh3F+AoIpiF/bYBhuPKS2m2cXQLp9h0uu1zlqc4K75Ef5yMTAzkB+9w6ejYzgY4xvYc65z2P7arwCmDBp9whqjcV0KiSF0InBFiY3lNubLJCpwVDg/al2dJWCOV1qbWXEVtJLMWxyD7gEnbMPA9GOJtIAp4mqnZs36ULHlWKwxJywQ1zqGMpDk3heA3sUhihUgIKFxy/fs4PuafVqPZvI8r80p7eFqc+pSS5z9g35Qs7YlEZD2My4RXbSC8C1lFpETfjoVLjWlt+c/JDOQ7m12iatn0ryJNN9VUA2K15q1D4Fez+6Qua3vYfJyj1HABel5gvMYzEicABKnecjUBZhINguKxHGaLJlPVr2g2CkCik1GS3FkV6qSyUPuIPJ9bYsEcCRuH63AL4aLYDBSNIzlpJyixYFDWXoc18fsFBe0Cd33APZE0e5IqHjzizDg7b4MlX5cCvjbtdAX9Ho1RnestJ0XKKkEh977AhgjZGfuJwUkV5UXPleGXKNz4lEPr2e56NMOiaKoKpsJkcKHh8ynN5KzkPnEV3bGs0MvO24NAZMN4LOUAgO0F/mNHhPpuxy2zUKO7xRhmdj3UpodyFEY5WW7ZEULNRnwPndodHCF9PRmQSSKd+oI7Y6+rjbOGenJ1/XgRYB1bGEakh8QWdiwOP0D6YmbL9RozdJ1+qtvg02nQAEtpAA8zIhrq6V4PCWGaEYbgPQjh4yMz6GFIDXDlVXMnsSZTkgo312pU+ZbZTSDlodPoErh2TxNIXc2ntUN9eagFTWjJsTXdjnCDeWknVguH5Pxs8Znc0RQfUyyWhNeJvhcELU9l2LyCgrnFVnfkoZVR30D3eaSSh22DFtL/QZgU5l36xslrQXqDpxfg4HmIn5HhoFjXXPoQbh57Kg3fIHd0xjC4/9oUEGiBe8JcaKwpsD8DvH0FQCCv0h1Qm9pXWVRXYpfRrcRinaYuVm5T1hhW7QmvUV4NCtaGCkJbeZvmCRDetIr7jAEXP7vM28avR74D6nb6Uc/vaO+nkK171pPX7y5QTpbCbuwj2MIZlDo5wRWPpBOtUAGNBrzxc2HeQYWAzU40lWizPkAyiUQQkwlnnAIol3dOZop1XFCHFUkugx+0LQHYA/+8Qv774GsSUJa2xqgeGcNLNKX4yQ9tkk326o5k18Mt8jNIcseZVq8JDmSjwp7YXtHRHZDKGB/2OTPN30gcP9z7cGL92rJGYlp3Lb9uz5PxYDV0CsKGm768mDhSraoWC6V0OvFwMKUCHBTu6CsVSRkFoKpBwXYqwk7VHATmXMxzOsW4d6yAA1CtBS9N5q1s7Tep2PyhE953NZdrboz6I3rTAO1vnJ7NZ3NSo4+nBwGsdZ/vCLs5ktip882ZGbzDONZqGAoPO9Ox8GXuk1xRy6mcBmR8i7hzpVDgNvWfejCHEwXovPdGSM+eoWC8pfbUbHhZiAz1WBDUIqXmEeFJdlWsLKvAKFDWT529VEnrSY6kbIooxdi9WHkuoWaJDsQqXLhkAlSK/aetrdM/2lrqdzJRr9Ff/GNyQwOKhHMBLAELTS2cXxI6K3zXgKp5tVS8yDGkCqXKw1gN1W1ylxX7tFeUb/nav7LAV+CRbXVDmFSMVidz2KOGr4SyApTaeOXx1UdoNGRYJ6aX0ZtLtQ2d9+pjz2Emz6M2FbBf2rRzb5UQqJ9pD0FTeE1uA3+qoQYpc0eyOtzzmi5tLlTglR2GXUZNlugQP8e4e9dd3czJdsbxqGLM+O3Pky5j3Wnk4QukqBgEhWkitVQWSmIHyxux92AskiyPXKq7+xY6CgeLWKX4rXZmIesVwBQWmKCkcjYpAxniLJYvHpaVM2V2THJbGv5sCKZq/u/ippG9jhQLWwk+K1SBomjCy1k9+b8tm2D6qX8R4TbV/7YyXA6EUg2ov6Fj/UqkVrN4Rt9EooWBnf9pBnO+c92nsuXGrrZ6OL3D0Z5WQxaBVMj9lxYpoAJKMf9vcLcLR9U/nmmkXvVVlTyLmFT0lhGpG/mx11wAfH4N4h5ZUPlRW474TXFFB0uRYNQKrrMYkImNiH9c4BLKx0RWPcqQvrHTEa7gIAAHUKDN1J9IzXvh4AfDway70yrRvuBZwfnC6C67Cd0XsjlPgn6Ih2yJ8h2gE8Br9lC+wb77HA7E6aW9jnrnMMEIkMRuf6HnUpdTavMAN9vLaLx6BQZousnKE2W4Kj88tasboRsIZSziCQbWkpT0s5kfj8SSzynT9YNBAhTGpefHd9zOExltYZFxWNI9N1DvUKgqBx4Rdr1MfppZ4x27N0fmJGgotU0h093nWM4HZaFqNaKR7b54S4WM1Z14rHanApNdt6IBmMZVxlyL46pbxzazDWZIGr/ASMLT1wf2EaxJdNPU61/nZ4tRCjBzOihY/QIKNgideujArg7fVyaqqXNwtZrj5Oq0CrRUPZXmcJmz+9F9AE53Qr/A4PKrQ0p/KezdXnyAJv9Jmn/Rcu50yrFvNDgz7YFD8q9ygLucJHeaj1RpR9qH9C39BKfn3yr9Lcckys5SiPmi8kCq0Qv+dcBTxkWNNiCuWzkVcosrCr0zWsmuhv6uz5HTX/+4k8dxHLpzgRXomXJT1e05IGC01CWknv/DtVv3XfwrRuOgh8K36Nbt6h0NBvrnp5XaWSoX9jRNVfTHsD3lAG5Ivv1wdRz/MZRYprEXfVGn1qk3GU74b2iPtw9cjXZx2lELEMpFS+XKkzedzA4I1RJY2nzuworOYSU3zSIm9z3QGy0VeqlHUqmS2UtpDqZ5dJz5e99gEFHBJqI5zhdDSNjd8ogH7xmFQwX7dAPieE1cGz93ZvEiz1MPI6fL61ZCC7LVM1ZSwmc+4hWGb9fE1wCk/8AjHxjQWBPthPcLvCKyZe3ZeR6SIdGEF0WzK29H8f57m3IkLzRm9Cde9GMZg/G04rG7rzpRZcpHLBS+cm73vy29u8ndVnIMLzmH2YLYojtOjYihmjKXZghLkOdjcg2AVBy2AvygfoWP1FvK09e8rNJ7sf1ONnf/aXAYjipOyxE9VDd+DHun0QMtmkKAk/LzF6HTf/s0e0k6iozIBmOzm0B7+lKwmmV5WLdxR/+3RGzp+DEAV0kIYs6SjbFcN1LVsF47JQDQokbWwi0Z4ROPSeeB44w+ipPsxEdq0VcOiFXvJvhlLPGwB9HoQr7peXVBfXYTjczjMia0wP9ppc5wu7uczrX7royzxKgvWl/gX+HzcdM11BlB+RbbbsJGjfzhk/+74A6D1znfjqKGgOcqNHASEcmLAYKYFtgnFMB+dddQE9C7GOlHM5DZKkA08VQiUjC/VWie0ZrNaRV3gpMUvEx43c76A04Nz9Ni91KS5mgF2ZXefQqTQn0AhVykIJrAiFk9EoBxSnyq9kXdXAMA9uicFul/f+Bw2AuSYH28T+mMSqSrkpe7qtl8fFmDLdTmp3soOlcCS7qrRHf3+q3yEP70AcJdWRU7gPqFAJiLbg85E9Qt6XT2uZt/Q8XEwO8L/MMVKMw3PDqUijbTNAtjOGlQ9zSAdLtOehYNjQG2rOBbMAB+qZzdXMsJ0AqAuybBxk+7LaLWA6whc4X3aaV9Hd8NMPT+t4SgZvZKqb0pqo3R/KVPDMoqXynKAKqrrLLT+H5U+VRmGPRK73efcGaXzTKKJelAfAGUAi5dUqB4M1vJH2SsrykTZJgVOnm3+wVmwFH/NF80ipvGz4jU3jCl2LZQVT9T7mdqeI6hDRUMzcJtiFlKxK1zPrZHJHVc7hBlJH9sHT+GUk+BI1hPZR0GyLFQ5fBR6s4jkqR1ctuCWMLgr4szqVZ/4HuKC3djb0oY5IF4IJaDXIS4Z9p5cMGAs0Iy03CPfiuorVmARFNkU70uM8vPrLaQymyJz9kLsEy3weBqfWr/zcd88xW3CVchlzDpKR4SGAQ/x6pNM1qhL1AX+68nAvoSr8fUfsslPjlmE0oVxu3Bg3jAHo2D81l3TiH3kAh9Tg1yePxxUtcgrhnrh/vrUA7R/uvcTLsCws7c+ZB9UemRilxlVy4oOlBhewDjy1hzEUEvoKA7T/ewmjpO/qW1RHJcGR9Hy9n9FmFW9Vr9cuAU2vxM/7kC9FGrB0r13+qCzK18XJVxJrL/IvwyI90f8SOHmEaRzYyazRYl92sI3yHGZPuB4Pi998F65vB9l07DsmT4SS67sMqjeG/ztMzsLUMDJJenKhltD+yd3QpoGjUigDcJsVdMbZt2sGQW+SlUt2jnzsQUqZvMoSyRpISufdMMOY3uBEYctzwEMS4aHU/Dgdh2Xlb9SrPJw/M1VsnzwpuFHYhMXxKsH+U8OXzmdLTy89bW3mBe9OObX8CO/tVYSQIvpiTz5HtR5Zmf1TSx2hkQM6eHckwTNvZVkNteKBpJ2k8Dk7T759Rf72pQH3CuydMibxS1L6WEgku8Ry9MFUJkrpqhLj9WjfRQ/zTNIU2UWCQfkId4qNjAnwfdOdEP0+ktjbA18TX9AEaGkr4sD1Tc4bt4c/Z75JirjzGDMZyBeFydZwQBD2FW0+nGT+NutFUfYAZpGOYvJi4y1rx/hnoNYRg0Te9QxVo094npUank+sZyBJ+qb6JnUGmVWrV/jdI0sFlA7N0hCYE7sw8JMzXpNb9GJ35lGcqZgSqPCBvWrfLhEASESolPc4hlPKPHwVSQQS3DySWp49BPMjBxy6GBW7EDXymCFaueZi5i4BZDKrSWhmx6lxRBC8ViYGGyRdOc8nP/w5BV5P+e0jUHE8VRbZnrvFZg8mopTvd1efMVN4r6ADD5h+AOlF4G6gq9rZCCOFqWUXN/NHoTI9UVm9BrUkH5ZSqQSPpmsSaam+EAK9dehn2IqTWit6w3sTeidVicl8nL4zkDbvaRx0PAaCdjriQwVYT/N1wLnjL6AisUTA0jnqFcRpxfiZWPumfLeQ/iig63vHhikpHOCOBt6GVOlJ3Ge1cFPBUMCSlhE4fti5zq/m6L/hM77+O/qlYJudlXVjd6W3LfBNVNQz8FvXGo+KCoC0TSH91PA7ogCJ8KMIKd2yW9J9oHDYMPB4qojuaedm+fzikLxMFJEx/lo4aX7aZTBdyj8wwnkaqE7LbI4HqA/bi4yz0XwNc0i8VzlFM6NamVmwWyqvEPyG2lZ8tZh7tykP2T2t0gfGzZdObBJ7nfKg2+d7J4z+fADyzfZzOsucgBMwW2yZRFdmnvwkuRExXF/WfKnAiZqZOZdg+CwamlTy3UsUT56dod5HXjqag7xOGQKyxnXP0orns8BylJUPqioYIbwEpb45xEAiliMB6i+jpMySdPkqD088FBrI+irJquLiyfk4gxRkA+lTIMpABeKnBee4VqlgSZjq72UKLuzsPWrQ90WY1kXq8Gu1fzc5drUWAJGBvJYJh6njKFxCxSH5C9QVvmHTQeVsnLYakVIn2ugb2+nPaxmbzqe0NqSrltFydoPq6eaFwkPfysnwlsV+yCxe795NtHqIGx/7DNSaXKOzkPgJohEXR0aJ0n9g/exzw5moes8rohKEGn4mOpfQfEcYcitrvbNjbVXrTb6A4520l73A15/TFZP6Bur6RfVfVV5dxo/+TMv340v2jKdxI3tu7etQbTCbBjw+vmrCdaZq/rgmA+KLyEoxe4Qq8aDzPtv3uJtfseIEYHiuR164y1C68J84r2Y2qfIxpsaQDYXsolPLYSkd2Z6YddWLr7qPNF1LWxVz98oVS9FShreK86y3lGjoMpzOSeOh2L2VSfq7Jbjqvo3ROx5wDEmOYnK0Z/v/vaGnAbSavq7+MbfD7qcI6E98MaCqaiTCssKyP19Vd2cO0jwc04OxhibI+7cdLmJGcpLkjue9vzJ5okQKbDdWJ5Rr8BZuJKgFAc/b3VriGI5FloXAVhyFslaWwKn8j+IsG8KiuCb8VKHS1mjNAEKGAO3mm4mgHPzs5NWm9X9YzIGlyiWpJ1WfF7MOi1HXS8sMRHtIlNvYaSSjs7Y764INzA9CyKzqDZ2JMD+cAH9jFgXHxV3U56PnsnAjyL86qlGz8yOMiQZaoT9Lj4sgJA1lChyATclxPKTJVMhWPn0CqT4Jz+7csIKztj4gor5+USc2KRV6u6YH1PPWL2L5N4T18AYWXLHlO/03jCa9w9iptKbA+Yjc6hj33cznVxeq/Kpa70TEA+D8zVyUeCgON8XRHl7KehkaM+obsVrFO8Py+s7gA2bvs7ZUJEZg1p7dfBTXWq/8UyZCUd20zhkltUYpUzX6L3yykS2sJXhSf1ttLKXqTtOmMSP6pX4ChpJMZhsGgT2oWSzL5OvMCFQUropF+U0C3whXBEHlMbBXENu1LChVykUjB8Y+DLIWEg4+eYU96UIgKGqdR3YJuMo05DwKsaM6/bIvVU6ZcSUKjFBoBqbfnjZtOYzZXVs0JWB95YZEnL0Lt61O5/PIJ2eyG7vlFBV0cKU3bBuBoIM+SYoSd460twNYu2YJEkqG/9Y4RSWuJWCDQI+YOBd627GOrtEtZtG/KoXyHxrwhDVUrOZkrHKxsuTXGAdGZflaLc2UFBWFRNcV7FeSrezmT29rHrixK/bGv3vRL6LykQ+FisnUlvBLDNsQPrbk7C3MIM7Xc++FQsqIn9Nz2EkIN+HWfwuY3jXBf6hHyluF+2w10TN5xIGgHfO7sg3vw0+IACODiEVMdE/J0L+opbkqCMYM6pNTQmoH++yC6lEj0dwDIO1QoWRxubXYi8EltVKOSwo6+cyBWF9J4RcNLjmm+N/zHt828rdSkBUYRwiVIBHR0y7wqLqCoGpZbFiae7zOvAa+h6xT5y3ryyK5MUmuv5hcDLnjV7QrhLG41FWbrxtXtRJdR9vwEGi7Eop5udB7RxXjMkEMxCaMSokKwt+E8VsvtT/zlNwHo6SuZva469ICCbcNPx9y8NdMpu24fBTfEc5SWInOx0jB/LuRgcHjxX80k3wZ8CEDC815bNmrGRp9eMhK0tLvw/+dw6LJcG+UdSrkCv22ZWgtBSyOrQVNrmcW/YxZsl2lPwG8LCi3GaBCd8tqGTSTu+OE3UQxV7CXdr1cHd6pfZzlDnXOD2H0yIO3Wm+7RtOlK4awRt72eFcsjqYm4S4cn22toauXck87DjdulZMbxoIdqDPoU5WMf/g5mMGi4J2ttRmtRNJkgtrjt4/Q43qKpq/Kh5NQvrgu9UKNipAgn7fNqSYQ/SKBtVMY5lJuMjNs7Iben7I3p7WIszEesw1lGlrAaIA4ZN5hWko9Ws4MUeMuMP2SE84ADpR7xA9TeD0UpH9d0f1k6QwoivMpvBH7wJIis/dQbdQ+h8n8zDVOyc7mny5yS1vnF2oODu+TbLtqm99UY48+89C9VtHeTjz9XDL5GLVGUETL79eDM2Zo92BmaCcfY4D+oPm7XtaCFlFEIQ/Q/Bpxovz1CFpt6mXorzR7v+5S/ozwLhPDI2tq2XcbeDMdSqQhoOiL0VSP8yxCBbdxuBVqA2LMyg7ETUGQlryoSlWsixamfbzvIyIliwAYPLjlPjJeDSBEdZMPAX9S/rCtekb/VA2Vy+Fl2rRdkHJo8om6vHbWj7MpElst7RZ7W1SAwhFBydPwQBWP3pXKAki07ryf1LP9weXB1j6YrlRDyb0+TsV7Maihaz6fQOGE09E4lqwVZLocJ8XYwu3/pN5w2nqCNrUsNo7YeYnjwlUXRoaLhJSn5o5GGv2wYFHVtDHNA05rZBQo25wXtMfsEFDj3tAh3dimTd1SyY768HCOvd9bcVfYf/6zqkspJfXe287bfhNlLbkjZNXa4nYmWicAkhAQJB3zTu+R2n+y06jK9nDApvT5FmJKPfBjXIA5gd5A4bKxsob2gTGHDlHqPG/ksqpqGxs/nChI6EKioxob8Jzts7qBMWpax7CjBEs3/NpebIFqJxZtbgQgobR8oT8mXwo7WrOnhOjk0u2Z30JVTIoDqH7KtOIfLi8L8OALR9zyJPOXAv5eOVtIC4ZQDz+X+Sl9GU/sN/lyj/oRda+EkZ8yQIXctJisCrBNpTueFbS/7UWk5oxKG9zwqOKlKEM3Na1B27/aDWzJZpJKM5FPhrZTMVAMII4ypvGZoU1kImCkcjZRH80mWR1nzs/gwxJK5j//b28KDe1MxsGDbZdI2QUUO/yBSrL1g0SWjK+nOBLsuAChWnsQ/8Oki3ZGfwQyCjgBM3/toW43Xi3KjKXK/tC9INRun+ahaPFxpTnU8YW/1tmjHNOHtyDXZANO+dro9w7ZKd0db8+HZplZmCdzEh2CAzJLh9DWfflDDCkfBEiX3xeP5OPn3+XWV5rJtDavw/YOEQiFDnU/ZMoYvo1sqmYpMeU35ruYhkh+5KtBvpaV/fxRqfBYx6ndVuhQBI+YPGi389gTj+LO9RxISzM4DSxpb0z5QICfXrKSIz9XpLRlZUbqlBnUdZqHQ1cEteZXwhaPcqfONhvRH9Zz4/ExxHwCu3A2Qu14W8OmgbdktUF+oonj3RTYs7RosRMaDjnS0vYmTDDFvYoXNJY7RCVgqRicrExnl2QMsWQJeKqU3yUwCNhvWYB/jo7+H9k/UqfOBb+XZlM4JSMNbSu2RIf8le9USky9mTgpOjr3eRMnHfIwEHaPZ8KK2UVoPVGc5HIwAAtViwduyVSUd947cwuO1/6Uvf3ynCwfKNiLICXNhSa8mLEbTfSc1aT5AuN/GkjU5E84cCl6Tb3QJs6wIaZYd8QvuR17baegtGr/bFp8nH4qk5HHL3kuFE5sSlmMtfPICRFW4KHTPurpOX6hKfvqiWe8W5JBd7OsIOjpG9tyPz2T9/pb8/zo9SHgTpw9NkZpkcXCKDC3Vi0N7YM10zfZB4wZqURn3f8hj4N4Sa2jHVFMs99AXz8/bHCPBHKFSzTN+cePloSYXRKS4wi4kpWcXFMV8rerOy990Ighks9nAvLidE9e5pSe7zB18W7asPFn1GEZUeoocMcO3Hqd++61riiYGoZkQoilU2noyOIAMmEhBxsRH2pxET/g1fLnzEpCsRMc8wDblQ7kib9i86CjmpTZtpf/8xOXLu/9+7Qoloc23YO76tf2/2Eo8QuuSZrXNnCky9eR7z0VnaG1k2pUbkgdG43B3wgE7AWHYqoBYg97l815PrD0fVWgwodHxOsmKtBWl0W4uy8AWKdYAzvimcXxmYBl5lK4do47PHNykVWmgKlGUlbyejmaf6sRuVFRcLnlNO07X/VWClTs0h/yScmU7w+f4KaYRRtCUZOCN+iiKN/rvt2nWhA4UF4uRoxTXZymzo7zRJQfsdglKga6rfLNKVKtf6JW3Wa/xKGRinmSRL+IozvLtAzIZhn5/KiGf/+xurJpLgf9zVRH7FGi2As6vC2DyEQzhXZcnIkqEX4cvbMZAoWTCQuyxAQK0LzQOX3i6qpM0hc3CWgczg5SRJwUwRJFHAW9gDxgYG6NKULQ2PPFWGij/MxjvxIxKPVMc8kT5mt5OAGL7pZ6WOqVZAphpcrKWUhwTOk/FLPF9ui5wTxtXzeUyYdfAk66dGFUu48MnzU9ZFYS88Gkk/HRxPUlvXO9cVQw/h3Imd5T2G8EPu+Mm/wqmFse8kza3y3wBckjh5lslSc8Rl3Xe5ejmsBVa6ImIt/v5TtXDPhJ3Ah97oLgy6M9qXhG1GcX8OFajuWLRi/pA6Mj/yV97Xlk+u6HVu6OirgiLAcuLBGMP5HXN3DAyU9m5IcI5tynR93CXP4RgCgSB98FUVjUk2rVwSz3dJR7nbvVuJssOVmpUe3QHjKmoesVqCYeSF0zRHf/dHuraJ81gOrLDySTc8WP9Rc2Sk9kmS7KkQrGEcyMcnWVe3Hm8n1zR30z4/XfiHa6hwajLwD/o3/pSDKZHT6NkwosmJLq8CY+tULLFw92dAENC8ogxAO1oDLjiHjh5dhRS9aOizo2Y5FIOKi4C5U07kbPHYlly1oTmCmAEQoNyJQgnBRalH07CdJJ1BDeRD817QzJn4BZdFz2YDj0WZB8GjjEimMXJo+6FHw/sGLJi2bgTzFgKF+bZGQyHdOhJce/6/ernAypcONlz7LrX+a4M54TxYXmRk5e8du3p15ISowv6Ur9EGCH6NDWAkMfAfn18K7ytCfy7PfkU1nQrUstrGqjpl5cd9FpCegKu1XA9b/tTBjCYvpR6ZtANngDOINmVv7fKJl9CdHXYZY6qCA3rGYhp17KWJ6wcR+P8cn0yXHALwT4S/zFabliAGfuhK8Zg0zh9r+7bfNrqjzrgKSRY8kMk/NlpuRTLVh8AlMOGOqyTbHPIK9wUudGK1XZBVioBhT2P5SDIgZam5SfUPOgqek8iysT4ftZ+JrOLtAlmA++Zih8URfbc6XZxTz3edlv1THsUFMCEgYLalFEz1yxR+Og9vdeXmXxdeDUTfAee7t7aQSU3SVd3o62FB+2EZf5vHiYTaNRoAnixdce9Jh46v27ntY8Gbtqs/lSuMLTyWvfE6fA9bKAGZ/qx9uXxrX+jaF3SngFu+BP7q5ENzgkO8fxg0imVC8P3rSD4KWod4ICri5ChnHLPjcNqg0GAI7rO3/qcx2mz/Afsj/4QCdrVyWXWLesm7075ztM5vR/VtNA7ZkLL6gR7BwT4DwIxNGlIVb7Fc40jGEcSNiSrncZfXnAG0c1U3cMLalCogafvqtGDdTtDs6J+NGxG9LuFYxwdqnQF1UAN+I3QLrP796S8rfll1qYb/ns+XSXKNmavtTWjKuC+xGqeysuOAUhga6YGqXnwMNXkFPNzqxW9bbSB62R9NKU2kRM31Vczb7PBUzP6Z08Fp/e3OUo+Y6K8CU21ljkb0Kr2uFS60XN+fjD57RKv75Os+lR6G2s1U90p8EPpgZjT0UgzqDudsOrbCCfvSGa8fTdPLwBfVexgpxRgbFYOeqsya8hXPlqnYV3B6G8kGoMsKmdduTp6kzauC0xFSYFN2oIk3tPvRr3cru8qYzWbxwq6bJVGbdiCAtiuJflyUDP6WC0XfpbSVG4Tq4+yzzWi/3C8IQtvjv05TJnEdKK9VO6M1yTBsnzTbZ7WStWfSkheil59nNxwW3IUZxDLHCuHT3Q1rgaaNloKCM+5wpPPR56pweC4SSEgRsfi60+/TwGTeUrcKP6N++Ol3dzZxnFK/XZPyEqOTvsZO1QWOh26SO66z9jIvzFvgBYcg6SHjCNv2V73q+RtZG14LrvmudSIvqri/6f/kgtMB3HveWzPyd5DVcO4qbdg3YNKsWv9o/HIOTKU3NR/eCpEtIbc8p2VEAFmspI05DPXBi+M1AqtNxrlYQO7pmgr7MSAT14RyVSlmV/QA5ZIPiGKfIXbq8fKD9SvowvkQHEnnIYaEsN7wG2WoRGbTCI+Fh1BW+RACeHWblDOtl+5JCt1eLUGt6rGnEYM7Q9XvIIDGYUja/YlKjfD6vaIRsPF5NKInJ33zPSZaNSUFb6V1EvfWG2qtnmvjJd904kGfKkj1dozpea69O4lyVf7wk0ECEfQzq5rL3a1IcD7IYA3lvc5kOX5/DOp5/dyQFsLbV+fBAlXLYYx6G+l4zn/e08YYHBqnpdOjnaCag0vtVAp0vLnprS1AjmHzf0SvxqNsO9pS/BurLHoLJCI9Us/KknY9GhDfIsOpcOhhoiz/XRuW1wm5WEXG+o/iQ6EfPRSrwam/+OQK2nJUKc6SOLngWC9xQmArXuXNXFSjHKmf+gt61WXzK4lQeb9CDqD5BaITTD0OhkLgB60Iw+DKgZqS5/QnMgqaFXNFfEpBEtbkeG9RoYVIOJlZASzqbOoTu04uMqRQYdpUo48H4M+VzlDb0nxrXBlxZ4aCrd5D78N0xNt6pImCKHVfGryP1O4i3WzDnvTV8S0SeXyILsibVBkebPuq7dTv8px28Eo6RWR6Sw+e9+qZeMCheW8GTjAw9Ova57sDGhgCY5yQ06NKP+uXQY60d3uSPG7LrU3whQ5RA2JR4oAVA7bLbxn6aP6fTG+1b6BbQM4uCwzeGBJhhVAMVXEGRIRIr3cE77B/5ZYB8/Jd6Vx7DkEs4MAbr/C7AIsZ4XDoF2TDi94L+a+qXOZ8RsXOHVDn41hyW8Z+69ffu/slBWJj+STEGrSXVRQ5tLJv57KtyhBeCIvDdBZQ9+EsMcJNHJFgGjJhMK685QfTQG9o6umdaB/mr85H1u48YGIlrNa8775fk4+REUyJNzzKvXpu0Ra7b+eyQcDACk1q/J2Ybbsq3JogwTm/R91mJdeJLnN+9u8lItcl0vmeXxH3pxKHc9XsN6Z7HEPjMF+k90rKgXYakY6MKv5tLnWded0PghMR2Ml0G4b4kEV8t4+bpb5ZpYDt4IQ2AV0Qj2FrHPQp87eLuMmtrxlh7sKMUdjCzl5pt1mjhZ1YlD980CUwc3Ubq5lqcrkbo1fXjiSWpTD0zN9HmHyn99j0W+9fprgVNUGRzJ5JSZmCOFYkEUQN0Zbyk8Kr4zxZyR05/7Rag/UwSqKw2UC51gK92VzRM5JhfphiF15VuY90EVe+WXZ8B2GNy/jvIMnvh5IXX3hkqBDaA8YtBPA+L8B/9tDRnbGsavtZsu3ygjAduvdzJ8rdqYsErgvRINmxPWbajgQW07F26xPxpstSbSWcsbKVhwzuAgDfx4W97gOi3bjOP0Ywh2RPFTTqrfQlfOZMadL1FeXH38N72LzuMYipfel3l27CnDxDHvtzAY3HUrBevxAI1+FJM2e9aH/+pkdYqtkF6fjRzbwwGWRAMVeFIRe8LXRlDoJFhVPv+o3hFGZ6W0C2VRQJRjGBqPdh1in4Sd65kAdSvFbxV4CYQFPD8ziVoaADtKD9w0NsBxrVI2Xt90Zt6zkDsqJe18VDlluLjxIrS8z85MK/w2CifotlOjeynNBRqG65Gbps7FswgZQ/Cuc7lwD5PJB8k3JaI1txYIDpP556HyusZ3RdPqKIZcA1Fp0AdZhupI95jIc2X50mDGdQmnWIrVBOYNoRoh+WdsEU3lZQRx/eGC5k0G5EGRyHrTQxrDe4169SHk0lJlNXEXqNZhn8g+Sffa5tnBEH3p5yzDVcS7kEAWffuzEkL4Aau3EVYBlh7BSCcHPZiiDDYmBXO83f9F067Y1s7RJ/CPIv6KY9RGdD8tp+zpN+1UA87Ny2n4N5dinz/5uUkbJ54Ld0uyhV5N3YJ5evzlE4I7eNOgmK37qBaR/WJBz4L8jPD3Nilig9hDJ6mBRsRO8yOmUe25LSx49jWsRwVBHamERNtthJyZaGCjmhwCYXMtp/3bexdYKKNcjUYmsvQZPuE4pB0avsWHY/Kikqs1ux7ewOGwb8s/nKA3kpJl1pwKVWXcgHGiHSJx8N85LX5w0nSegohvfFrq2BJxVvdpCOkXLhsDAD5hDVy7oenZSNZHntJDLt+oQELSuQhlzPgqGi8e5eKYIy9DnlnFIkNLPJ4NRAyPpqQwUvrI2FbSvS03Uflftz0FsSy5C7MnTRugY13OTyTD1yhvSwANdSb+sU1RR7Ih9Y++mb6gwwPuMUoFworptdx69zr8ZCAP+/ftH18yAMLe7U5/qN4H4LNwKyPOjieGrR5G8GTiu3cryMTRi2Z3OFMINvhaV+LEUFZKwRwt/TCEVYohX1UAETBVSvL9Cb/I2rSOZV1DXmw3B8PdlayBDcQlys6UQr05+f0xXY1XslCg/2yjEJ9lKIfZq8W7Ncy2uPkb0AEe2Dt5huTQYNLBcVxJw04n1lVx0O6vpOK1/shjWQ3ZhHBOvSw5WJs4ekAJG4uMpZwdyMzY2PNZjmdbtQHmL8dckE+2QLHIiVEOkT7NkMKYtNASAopvqs36d3bw1MuBK5fCVMMFG4zdTgkjjT5bCfJHH149lXRVnPU9JgJG5MZshndOje+5bJrsw9a2nCQh3NsAdZwv+pRqNSdyGLmNjF5rCgBo0UCcTA5JNz/cEiBhE6enaDflM/ONlyjMKx0KcOv4oRTHlfzxoIKdNM35Rnj9Qnc6RyVe82jB/1f7bxlBeY2G1hC+ojpXRqmcBq+H9SfWfU2lvFbs/t3Yi3+b89CmSjmkzYITKj5NOoGsrtFeh2/RfMRTfeSwqBh8Zs6yfCAMPrFBlhJjlZMXiggmBtKRjdDOll8okyBWZsqtLBIV2iFoDV2LW14j/gGb6jxE0jkXL0f4F+J1194GDsDreCS8IJtaebjvJxpeAgL7hVxPJtXeryjey1Vcj1YD+LFkyz6Y9HPq5VuD+AQW6cEG7UDt6W6vA6fl4K5o/QZ8vrVd6TLVX9D0IOZhIFNYtWTBfGGMX3BTn6wBOoJgU8UQF6jmT7SZ4MBHJKewMPkI5sgNME5S3vwmMC9Vjlwhx3CT25rucmW/I7i+CI0N+lpHFLLyD57U1C4ottMKpZSLO26jzDnjFoyvtQZYjPWk6tnFnur2MNI2P0Hstq5hIcr939HCGVgXX4IspNrFVhbilT+jLn3+T1/ol86nQe6BuHIeCRcTLYWQyNLrl2pE3EyuBzoF9bR04TFC+WPfVuOHti4i8IItMHT1alOxfp70XJZPFX4pl8zhV5f53ZLAtB7tYPqlUBplBPiLxRdNpU78ZumpzzVf+zm1bqe2JTjNUAW6fe+8mn2wdewGmFZSEz32ymxnPEU2T9Ejg62W9QkSIwCH24EqiY+hXcA8oBbaHNm3Z8ImRgEXuk9Le7UJyQa2ENt1OhraIc7SwuZPU9a4ViKWENqZx+BlI20TW85VAbondTa18vMxLoHhYyRC1lcMgon1rDk7gVLTSoRsJ2KKRn2SvPpIu2zLi3NnQv1Zuz2WZ0ASxPzE15IjVa8vMLb6BiotHDhVpIN/Az5vZLKLn6o6DFWnfvIsw5PxFi/evj3WPALM9wVcn0aXmI3z0NAzxg/m6C7trcQmu09N5Ma08Q9GkE026g9DP9ZrG/o038BJFVCdL9zp5VU3LpgZmkE7TYF+IIubti+QXEZ7eApVE23Astv9eaF5vEX2atXZ8/40q/+ISWTVcYagCWiW5i4DPVTbpxzdhCVdHqfNPZMevzQVWhJVN/paR4adquVFIAYWAMYq7H1qLRvpnaqKvoaEF8nTlx9RvxIysnK+bMMkyjTwbiOcvsuvU+KGyOlV5Mg8K4T1n14xNUa/FtBDyPTmP2JJAzcU= </div>]]></content>
    
    <summary type="html">
    
      To Guan
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GRE Notes</title>
    <link href="http://bingcs.com/2019/12/16/GRE-Notes/"/>
    <id>http://bingcs.com/2019/12/16/GRE-Notes/</id>
    <published>2019-12-16T09:20:48.000Z</published>
    <updated>2020-07-25T09:58:18.867Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Something-useful"><a href="#Something-useful" class="headerlink" title="Something useful:"></a>Something useful:</h2><h3 id="1-单词"><a href="#1-单词" class="headerlink" title="1. 单词"></a>1. 单词</h3><ul><li>首选：佛脚词；备选：再要你命3000</li><li>一星期飞速看1-2遍，或者用Excel做记录</li><li><strong>背单词的时候关注强词性</strong></li></ul><h4 id="1-1-词根"><a href="#1-1-词根" class="headerlink" title="1.1 词根"></a>1.1 词根</h4><p>具体详见<strong>《GRE核心词汇助记》（再要你命3000）</strong></p><h5 id="『说』"><a href="#『说』" class="headerlink" title="『说』"></a>『说』</h5><ul><li>dic/dict 说 - abdicate addict indict interdict valediction vindicate contradict dictate </li><li>log 话 - eulogize monologue prologue grandiloquent loquacious obloquy soliloquy terminology circumlocution dialogue</li><li>rog 问 - abrogate arrogance interrogate prerogative surrogate</li><li>voc/vok 呼唤 - advocate equivocate vociferous voice vocation convoke evoke invoke provoke revoke</li><li>n(o)unc 正式地说 - announce denounce renounce enunciate</li><li>verb 词 - verb verbatim verbose reverberate</li><li>or (恭敬地)说 - oral adore inexorable oration peroration </li><li>fa 说 - fame fable fabulous affable ineffable infamous</li><li>son/ton/phon 声音 - sound consonant dissonance resonant monotonous attune cacophony euphonious </li><li>vow/claim 正式地说/声称 - vow avowal disavow clamor acclaim proclaim disclaim declaim reclaim</li><li>mand/ord 命令 - command order countermand mandatory demanding subordinate insubordinate primordial </li><li>cant 唱 - chant disenchant incantation recant accentuate incentive</li><li>doc(t)/dox 教/思想 - doctor paradox doctrine doctrinaire indoctrinate heterodox orthodox </li><li>vindictive复仇的 /vindicate证明，平反 /decry 强烈反对 /prophetic 预言的 /euphemism委婉的说法 /sound牢固的，强壮的，严谨的 /atone赎罪弥补 /ordeal严峻的考验 /decant轻轻倒出 /voluble健谈的</li></ul><h5 id="『抓、拿』"><a href="#『抓、拿』" class="headerlink" title="『抓、拿』"></a>『抓、拿』</h5><ul><li>cap/capt/cept/cip/cup 抓拿 - captious captivate inception exceptional unexceptionable perceptible perceptive susceptibility disciple emancipate incipient principal preoccupation recuperate </li><li>emp(t)/sum(pt) 拿 - exemplary exempt peremptory preempt presumptuous sumptuous </li><li>prehend/prehens 抓 - comprehend apprehension apprehensive misapprehension reprehension apprise </li><li>rap(t) 抓 - rapt rapture rapacious ravenous surreptitious </li></ul><h5 id="『拉、伸、持』"><a href="#『拉、伸、持』" class="headerlink" title="『拉、伸、持』"></a>『拉、伸、持』</h5><ul><li>tract 拉 - tractable abstract contract detract distract distraught extract extraction protract retract </li><li>tend/tens/tent 伸展 - tendentious contend contentious distend intensify pretend pretense unpretentious ostensible ostentatious portentous tenuous attenuate extenuate </li><li>tain/tin/ten 包含/获得 - abstain detain pertain pertinent retainer content malcontent countenance retentive tenable untenable tenacious retinue</li></ul><h5 id="『放』"><a href="#『放』" class="headerlink" title="『放』"></a>『放』</h5><ul><li>pos(t) 放 - apposite apropos compose depose deposit discompose imposing poseur posit superimpose suppose supposition repose impostor postulate posture </li><li>pon 放 - exponent proponent compound component</li><li>thes/thet 放 - parenthesis synthesis antithetical epithet hypothetical </li><li>preposterous荒谬的 ponderable值得考虑的 ponderous沉重的 preponderant占优势的更重要的 </li></ul><p>『走、跑、跳』</p><ul><li>ced/cess 走 - accede accessory accessible intercessor precedent predecessor recessive secede； 停止 - cessation incessant</li><li>gress/grad(e) 迈步 - aggressive digress regress transgress retrograde</li><li>amb/err 漫步，迷失 - amble ramble perambulate aberrant errant  erratic erroneous </li><li>ven(t) 来 - contravene convene convention convenience adventitious circumvent inventory </li><li>cur 跑 - concur occur excursive incursion precursor cursory cursive discursive </li><li>sul(t) 跳 - insult result desultory exult resilience </li><li>vad/vas 走 - invade invasion pervade evasive </li><li>vag - extravagant过度的挥霍的 vague表达不清的</li></ul><h5 id="『坐、站、躺』"><a href="#『坐、站、躺』" class="headerlink" title="『坐、站、躺』"></a>『坐、站、躺』</h5><ul><li>sid/sed/sess 坐 - assiduous residue subside subsidiary subsidy supersede sedate sedentary sedulous obsess</li><li>stit(ut)/stat/stas 站立 - constitute institute substitute reconstitute restitution ecstasy stasis apostasy static stature instate understate </li><li>cu(m)b 躺，位于 - incubate incumbent recumbent succumb cumbersome encumber </li></ul><h5 id="『倒、流』"><a href="#『倒、流』" class="headerlink" title="『倒、流』"></a>『倒、流』</h5><ul><li>fus 倒 - diffuse effusive infuse profuse suffuse </li><li>flu 流 - affluent confluence effluvium fluctuate fluent influx superfluous mellifluous flush </li></ul><h5 id="『切分、部分』"><a href="#『切分、部分』" class="headerlink" title="『切分、部分』"></a>『切分、部分』</h5><ul><li>cis/tom/sect/seg 切 - concise incisive dichotomy epitomize dissect segment </li><li>fract 破裂 - fracture infraction fragile frail </li><li>part 部分 - counterpart partial particularize partisan partition jeopardy</li><li>scission切断 rescind废除取消 debris废墟 sunder分裂分离 asunder分离地 curtail缩短 retrench削减开支 trenchant锐利的一到见血的 </li></ul><h5 id="『感觉、感情』"><a href="#『感觉、感情』" class="headerlink" title="『感觉、感情』"></a>『感觉、感情』</h5><ul><li>sens, sent 感觉 - commonsensical consensus dissension insensible insensitive sensation nonsense consent dissent insentient sentinel </li><li>path, pass 感情 - antipathy apathy dispassionate impassive compatible </li><li>pass 经过 - compass surpass trespass encompass</li></ul><h5 id="『弯、折、扭』"><a href="#『弯、折、扭』" class="headerlink" title="『弯、折、扭』"></a>『弯、折、扭』</h5><ul><li>pli/plic 折叠 - diploma compliant compliment pliable pleat comply supple complicate duplicate duplicity explicate解释说明 explicit表达清晰的 replicate </li><li>tort 扭曲，弯曲 - torture contort distort extort勒索 retor回应 tortuous拐弯抹角的</li><li>crook使弯曲 crouch蹲伏 crumple弄皱/垮塌 deflect使偏斜 reflect flexible sinuous蜿蜒的 sinew活力力量</li></ul><h5 id="『转』"><a href="#『转』" class="headerlink" title="『转』"></a>『转』</h5><ul><li>vers 转 - reverse adversary对手 adversity逆境 aversion厌恶之物 conversant熟悉的 diversity versatile多才多艺的 verse使精通熟悉 traverse横穿 </li><li>vert 转 - advert引起..注意/提到 convert divert inadvertent偶然发生的/疏忽的 incontrovertible subvert颠覆 vertigo眩晕</li><li>converge汇集 diverge分歧/散开 convoluted复杂的 revolt使厌恶/反叛 shiftless懒惰的 shifty狡诈的</li></ul><h5 id="『看』"><a href="#『看』" class="headerlink" title="『看』"></a>『看』</h5><ul><li>spec(t)/spic - aspect auspicious conspicuous circumspect谨慎的 despicable令人鄙视的 despise极不喜欢的 prospect perspicacious有洞察力的 perspicuous清晰明了的 retrospective回顾的 specious似是而非的/欺骗性的 speculate揣测/投机倒卖 spectator观众目击者 spectrum所观察到的/光谱</li><li>vis/vid - improvise即兴而作 provisional临时的 provisory有附带条件的/临时的 revise visionary不切实际的/有远见的 invidious惹人反感的/羡慕嫉妒恨的 provident有远见的 providential幸运的 wit unwitting未察觉的 </li><li>insight surveillance监视 panoramic全景的 scruple不安 scrupulous正直的 scrutable可以理解的 scrutinize仔细检查 </li></ul><h5 id="『使做、引导』"><a href="#『使做、引导』" class="headerlink" title="『使做、引导』"></a>『使做、引导』</h5><ul><li><p>ag/act - agility敏捷 agitate激起/煽动 coagulate凝结/变稠 cogent令人信服的 demagogue蛊惑民心的政客 pedagogue教育者 agog嫉妒感兴趣的 react reactionary保守的 </p></li><li><p>duc(t) 引导 - conductor导体 conducive有益的 inducement动机/劝说 irreducible seduce诱导 counterproductive反效果的 ductile可塑的</p></li><li><p>fac(t)/fect/feit - factory facilitate促进 faction派系 affectation虚伪做作 disaffected不满的 disinfect消毒 feckless粗心不负责的/无价值无成果的 counterfeit仿制的 surfeit过量(饮食) forfeit罚金</p></li><li><p>fic - efficient beneficent deficiency efficacious gasification气化 magnificent壮丽的 nullification officious多管闲事的 proficient熟练的 soporific催眠的 specific </p></li><li><p>compelling迫切的/有说服力的 repel(repulse) 抵制/使厌恶 dissuade劝阻 </p></li></ul><h5 id="『发送、给予』"><a href="#『发送、给予』" class="headerlink" title="『发送、给予』"></a>『发送、给予』</h5><ul><li>mis(s)/mit 发送 - manumit解放(奴隶) submissive服从的 surmise揣测 commitment致力/投入/承诺 committed忠实的 intermittent间歇的 remiss疏忽的 unremitting连续不断的 compromise妥协 </li><li>don/dot 给 - donate donor condone宽恕 </li></ul><h5 id="『写』"><a href="#『写』" class="headerlink" title="『写』"></a>『写』</h5><ul><li>scribe - circumscribe限制/包围 nondescript平凡的 proscribe排斥 prescription规定 scribble乱写 </li><li>sign - consign转交/将..置于 designate任命 resign辞职 signal</li></ul><h5 id="『身体部位』"><a href="#『身体部位』" class="headerlink" title="『身体部位』"></a>『身体部位』</h5><ul><li>cap/cip = head - madcap热爱冒险者/大胆的 precipitate匆忙的/促使 precipitation仓促/降水 precipitous匆忙的/陡峭的 precipice悬崖 headlong鲁莽的 levelhead wrongheaded</li><li>ped = foot - expedite加快进程 impede阻碍 pedestrian footloose </li><li>man = hand - maneuver/manipulate巧妙操纵 mannered做作的 manuscript outmaneuver backhanded ham-handed笨手笨脚的 offhand即兴的 </li><li>cord = heart - accord chord符合 concord discord cardinal主要的 hearten dishearten halfhearted heartrending stouthearted</li><li>barefaced厚颜无耻的 efface擦去 facetious轻浮的 facile superficial hearken supercilious高傲的(cil-brow眉毛)</li></ul><h5 id="『尖、刺、小』"><a href="#『尖、刺、小』" class="headerlink" title="『尖、刺、小』"></a>『尖、刺、小』</h5><ul><li>ac 尖锐的 - acid acerbic acme顶点 acrid acrimonious exacerbate使加剧 acumen敏锐洞察力 acute</li><li>min - diminish使变小 eminent杰出的 menace威胁 menial卑微的 minatory带来威胁的 mince切碎/小步走 preeminent优秀的 </li><li>pin/point/punct 刺 - compunction焦虑 pinnacle顶峰 pinpoint pointer punctilious pungent辛辣讽刺的 </li><li>sti/sti(n)g 刺 - distinctive extinguish终止 instigate煽动 prestige stickler stiff僵硬的 stifle扼杀 stigma污名 stingy小气的 stipple点刻 stipulate规定 stitch剧痛 </li><li>oxymoron矛盾修饰法 paroxysm动荡 peck小口咬 pique刺激 antagonize激怒 paragon模范</li></ul><h5 id="『高低、轻重、长短』"><a href="#『高低、轻重、长短』" class="headerlink" title="『高低、轻重、长短』"></a>『高低、轻重、长短』</h5><ul><li>lev 举起 - alleviate减轻 elevate提升 leaven使轻松活泼 levity轻浮 relevant aloft在空中 aloof孤高的 lofty高的 </li><li>grav 重 - aggravate加重 grieve使心情沉重 </li><li>brev / long - brevity abbreviate abridge prolong linger磨蹭</li></ul><h5 id="『松开、拉紧』"><a href="#『松开、拉紧』" class="headerlink" title="『松开、拉紧』"></a>『松开、拉紧』</h5><ul><li>solv/solut 解开 - absolute absolve解除责任 dissolute无节制的 dissolve解散/溶解/撤销 resolute坚定的 solvent溶剂 </li><li>strain/string/strict - constrain restrain constrict压缩 stricture责难 stringent紧绷的 constringe使紧缩 hamstring使无效</li></ul><h5 id="『同、不同』"><a href="#『同、不同』" class="headerlink" title="『同、不同』"></a>『同、不同』</h5><ul><li>equ - equable温和的 equilibrium平静平衡 equity iniquity </li><li>par - parity disparate迥然不同的</li><li>sim - simile明喻 simulate simpleton</li><li>ali 另外 - alienate疏远/转移 inalienable alibi不在场证明/借口 </li><li>neg 否定 - abnegate否认/放弃 negation negligent疏忽的 renege放弃 renegade叛徒</li><li>altruism利他主义 adulterate掺杂</li></ul><h5 id="『触碰、边界』"><a href="#『触碰、边界』" class="headerlink" title="『触碰、边界』"></a>『触碰、边界』</h5><ul><li>ta(n)g 触摸 - intangible无法感知的  tangent离题的 contagious传染的 intergral完整的 contiguous接触的/相邻的</li><li>fin 边界 - affinity倾向 confine限制 finale终场 infinite </li></ul><h5 id="『大自然』"><a href="#『大自然』" class="headerlink" title="『大自然』"></a>『大自然』</h5><ul><li>anim 生命 - animate有活力的 inanimate unanimous一致同意的 </li><li>umber 影子 - umbrella umbrage不悦 shadow overshadow超过 </li><li>und 流 - abundant redundant多余的 inundate淹没</li><li>luc/lumin/lustr 光 - elucidate阐明 lucid亮的/清楚的 pellucid透明的 translucent透明的 illuminate照明 illuminati智者 luminary杰出人物 luminous illustrious杰出的 lackluster lustrous有光泽的 </li><li>anthrop 人类 - misanthropic反人类的 philanthropic博爱的 </li><li>chron 时间 - synchronous同步的 chromatic彩色的 monochromatic单调的 anachronistic时代错误的 chronic习惯性的/常发生的 </li><li>effulgent/refulgent 辉煌灿烂的</li><li>flamboyant炫目的 conflagration大火</li></ul><h5 id="『正能量』"><a href="#『正能量』" class="headerlink" title="『正能量』"></a>『正能量』</h5><ul><li>am 爱 - amity友好关系 amiable amicable enamored迷恋的 </li><li>bravado假装勇敢 bravura优秀演技/的 </li><li>boon恩惠 bonhomie温和</li><li>can - candor坦率 incandescent明亮灿烂的 kindle</li><li>ferv 热 - fervor热情 effervesce冒泡/兴奋 fervent充满感情的 fervid perfervid非常热情的 </li><li>lib 自由 - liberty libertine放荡不羁者 liberal前卫的/大方的 ad-lib即兴的 </li><li>nov 新 - novel innovative novice新手 renovate</li><li>pi 忠诚 - expiate赎罪 impious不敬神的 pious </li><li>rect 直的 - rectitude正直 resurrect使重生 incorrigible不可救药的</li><li>cred 相信 - credence坚信 credible credit credulous轻信的 discredit</li><li>fid 相信 confident diffident不自信的 fidelity忠诚 perfidy不忠 </li></ul><h5 id="『负能量』"><a href="#『负能量』" class="headerlink" title="『负能量』"></a>『负能量』</h5><ul><li>base 底部 - abase降低 debase贬低 self-abasement abysmal很深的极低的 </li><li>culp 罪行 - culpable有罪的 exculpate开脱 inculpate归罪 </li><li>tum肿 - tumor肿瘤 contumacious不服从的 tumult骚动 </li><li>noc/nox/nic 伤害 - innocent innocuous无害的 noxious有害的 pernicious有害的 </li><li>turb 搅乱 - disturb perturb使扰乱 imperturbable沉着的 turbid混浊的 turbulent湍急的动荡的 </li><li>tric/treach 诡计 - extricate解脱出 treacherous背叛的</li><li>tim 害怕 - timid胆小的 timorous胆小的 intimidate威胁</li><li>dam/dem 谴责 - damn condemn谴责 indemnity保险赔偿 </li></ul><h5 id="『字母j』"><a href="#『字母j』" class="headerlink" title="『字母j』"></a>『字母j』</h5><ul><li>ject 扔 - reject abject(throw away spirit/dignity/by_society) conjecture猜测 deject使沮丧 project方案/凸出/预测 subject受支配的人n/取决于的 subjective主观的 jettison丢弃</li><li>jo 快乐 - joy joke rejoice jocular jocund jovial jubilant 快乐愉悦的</li><li>jur 发誓 - abjure抵制 conjure请求/想起</li><li>junct/joint 联结 - adjunct附属物/非必需 disjunctive分离的 disjointed不连贯的 </li><li>jud(ge) 判断 - judicious明智的 adjudicate判定</li><li>justify辩解 adjourn延期/休会 jingoist军国主义者</li></ul><h5 id="『字母v』"><a href="#『字母v』" class="headerlink" title="『字母v』"></a>『字母v』</h5><ul><li>vac/van 空 - evacuate撤退 vacuous茫然的 evanescent逐渐消失的 </li><li>val 有价值的 - ambivalent矛盾的 convalesce痊愈 equivalent等价的 prevail盛行/战胜 unavailing无效的 valiant勇敢的 valid逻辑上正确的 </li><li>ver(i) 真实 - verify veracious诚实的 verisimilar貌似真实的 veritable真正的 </li><li>vol 自由意志 - volition意志 malevolent恶意的</li></ul><h5 id="『下或上的趋势』"><a href="#『下或上的趋势』" class="headerlink" title="『下或上的趋势』"></a>『下或上的趋势』</h5><ul><li>cid/cad/cas 下降 - accidental recidivate重新犯罪 cascade decadent堕落的 </li><li>laps 倒下 - lapse小过失/结束 collapse relapse</li><li>fall - fallacious欺骗性的 fallible可能出错的 felony重罪</li><li>scend 爬 - ascendant descend condescending高姿态的 crescendo声音渐强/顶峰 transcend超越</li><li>surg/cit 升起 - insurgent叛乱者 resurgence复兴 incite煽动 resuscitate使复苏 solicitous迫切的 </li></ul><h5 id="『动作』"><a href="#『动作』" class="headerlink" title="『动作』"></a>『动作』</h5><ul><li>mot 动 - commotion骚乱 demote降职 motile能动的 motivate automatic</li><li>lud/lus 玩/演奏 - prelude序曲 allude间接提到 collude串通 elude闪避 ludicrous荒唐的 delusion错觉 illusory幻觉的</li><li>fer 拿 - defer推延/遵从 proffer献出 referee peripheral外围的/辅助性的 fertilize euphoria感觉愉快 aphorism格言警句 belligerent好斗的 </li><li>port 运/带来 - importune宏伟壮丽的 deportation放逐 opportune合适的 rapport和睦 </li><li>quir/quis 寻求/询问 - acquire exquisite精巧的/强烈的 inquisitive过分好奇的 perquisite额外的好处 requisite 必需品 prerequisite前提 </li><li>gen 产生 - engender产生 indigenous本土的 ingenious聪明的 ingenuous天真的 homogenize统一化 regenerate genial友好的 genteel有教养的 benign好心的 malign恶意诽谤</li><li>pend/pens 挂 - compendium摘要 dependable indispensable必不可少的 impending即将发生的 propensity倾向 suspend悬挂/暂停 pensive沉思的 </li><li>ple 填充 - complementary互补的 deplete耗尽 implement replenish补充 plebeian平民的 plentitude大量</li><li>prob/prov 证明 - approbation同意 disprove probe深入调查 probity正直 reprobate堕落/拒绝 reprove警告/不喜欢 proofread校对</li><li>secu/sequ 跟随 - consequence obsequious谄媚的 prosecution执行 persecute迫害 </li><li>serv 保存 - conserve保存 conservatory温室 conservative保守的 observant警觉的 preservative防腐剂 reserved内向的 servile低下的 subservient奉承的</li><li>plac 使高兴 - complacent自满的 implacable固执的 placate平息抚慰 placid宁静的 </li><li>grat 高兴 - ingratiating讨人喜欢的 gratify使满足 gratuitous无根据的 </li><li>lect 选择 - eclectic多元的 predilection爱好偏袒</li><li>sci 知道 - omniscient无所不知的 prescience预知 conscientious有良心的 </li><li>cond 收藏 - abscond偷偷离开 ensconce安置 recondite藏在后面-&gt;深奥的 </li></ul><h5 id="『其他』"><a href="#『其他』" class="headerlink" title="『其他』"></a>『其他』</h5><ul><li>quiet - acquiesce默许 quiescent平静的 tranquility宁静 </li><li>beat - abate减轻 browbeat恐吓 offbeat不平常的 upbeat上升的</li><li>use - abuse滥用/辱骂 disabuse纠正 peruse细读</li><li>labor - belabor喋喋不休 collaborate合作 elaborate详细的 laborious勤奋的</li><li>test - attest证实 testimony声明 testy易怒的 </li><li>rod/mord 咬 - erode侵蚀 corrosive腐蚀性的 mordant刻薄的 remorse懊悔 </li><li>her/hers 粘 - adhere inherent内在的 cohesive有粘性的</li><li>lig绑 - obligatory强制性的 obliging乐于助人的 religion</li><li>imper 命令 - imperative强制性的 imperious专横的 imperial </li><li>dom/domin = home/dominate 支配 - domicile住所 dominant domineer</li><li>termin 结束 - terminus终点站 interminable exterminate根除 </li><li>clus/clud = close 关闭 - preclude排斥 recluse隐士 seclude隔绝 </li><li>struct = build - construct obstruct妨碍 misconstruct误解 </li><li>dol = grieve 悲伤 - dolorous忧伤的 condole表达同情 indolent懒惰的 </li><li>sol = comfort - solace console安慰</li><li>pall/pale 苍白的 - appall使惊恐 pall失去兴趣 palliate平息 pallid苍白的 </li><li>pot = power - impotent无力的 potentate有权势的人 potentiate加强 </li><li>sacr/sanct = holy/scared 神圣的 - sacrifice sacrosanct神圣不可侵犯的 desecrate execrate谴责 sanction批准 sanctify将..视为神圣 sanctimonious假装虔诚的 sanctuary避难所 </li><li>patr = father - patrician贵族 patronize赞助 patriot爱国者 repatriate遣返</li><li>dem = people - democracy demotic大众化的 endemic地方性的 pandemic大范围流行的 </li><li>grand - aggrandize grandeur宏伟 grandiose宏大的/浮夸的 </li><li>spir 呼吸 - spirit inspire aspirant有抱负者 conspire合谋 expire到期 respire呼吸 </li></ul><h5 id="『一词多义、复合词、经典词缀』"><a href="#『一词多义、复合词、经典词缀』" class="headerlink" title="『一词多义、复合词、经典词缀』"></a>『一词多义、复合词、经典词缀』</h5><ul><li>一词多义 - balloon迅速增加 husband节俭 meet合适的 patent显而易见的 plastic可塑的/虚假的 rider附加条款 want缺少的 </li><li>经典后缀 - noisome有害/有毒/恶臭的 winsome迷人的 wholesome有益身心的 fulsome过度的 willful固执的/故意的 playful爱开玩笑的 falsehood谎言 exacting严格的 offish冷淡的 worldly世俗的 needy贫穷的 windy冗长的 </li><li>名词+名词 - windbag健谈者 stonewall阻挠 faultfinder吹毛求疵者 shipshape井然有序的 </li><li>形容词+名词 - deadlock deadpan无趣的 daredevil大胆的人 blueprint blackmail敲诈 airtight无瑕疵的 carefree无忧无虑的 foolproof十分简单的 threadbare破烂的 </li><li>…+分词 - outmoded shopworn陈旧的 timeworn陈腐的 careworn焦虑地 ill-bred没有教养的 ironclad坚不可摧的 tightfisted吝啬的 thick-skinned冷漠的 half-baked不明智的 hard-bitten顽强的 painstaking煞费苦心的 everlasting永恒的 </li><li>介词/副词+… - downplay轻描淡写/不予重视 downpour倾盆大雨 interlock连结/连锁 forthright直率的 onset攻击 off-key不寻常的 outgrowth结果 override不顾 upbraid(braid辫子)谴责 undermine削弱 underscore强调 understate保守陈述 understudy替补演员 </li><li>名词/形容词+动词 - safeguard保护 watershed分水岭 cloudburst暴雨 pitfall陷阱 waylay埋伏 windfall意外的收获 wiretap窃听 </li><li>其他 - eavesdrop(eaves屋檐)偷听 turncoat叛徒 steadfast坚定的 diehard保守顽固 hidebound死板的 dated过时的 antedate早于 forebode预示 fail-safe保险措施/万无一失的 </li></ul><h5 id="『动物相关』"><a href="#『动物相关』" class="headerlink" title="『动物相关』"></a>『动物相关』</h5><ul><li>elephantine巨大的 lionize追捧 bully霸凌/最好的 ebullient热情的 cower畏缩 impecunious贫穷的 bellwether领头羊 buck反对/转移 jaded疲倦的 coltish不守纪律的 restive急躁的 spur刺物 synic愤世嫉俗者 dogged固执的/坚持的 hangdog伤心的 underdog abet帮助 bait引诱 </li><li>serpentine弯曲的 chameleon变色龙 gossamer轻薄的 gull欺骗 gullible易受骗的 parrot模仿 coquette调情 coop(鸡笼)监禁 crestfallen(crest鸡冠)垂头丧气的 callow不老练的 fledgling(fledge长羽毛)新生 preen整理/打扮/自满 molt脱羽毛 badger不断纠缠 toady马屁精 sloth(树懒)懒惰 sluggard懒人 moth-eaten过时的 gadfly刺激物 goad刺激 nitpick吹毛求疵 </li></ul><h3 id="2-填空"><a href="#2-填空" class="headerlink" title="2. 填空"></a>2. 填空</h3><ul><li>不需要了解单词的具体背景，只需要判断词性（+ / -）然后选对了即可</li><li>六选二一般原则是选同义词</li><li>只刷真题，一千多</li><li>(3M+WC)+have done结构 表猜测</li></ul><blockquote><p>如果你刷了七八百道真题后正确率还完全没有起色，那请扪心自问几个问题，</p><p>“知道错题为什么错吗？”</p><p>“遇到重复题时正确率能百分百吗？”</p><p>“做过的真题中所有单词都记住了吗？”</p></blockquote><h3 id="3-阅读"><a href="#3-阅读" class="headerlink" title="3. 阅读"></a>3. 阅读</h3><p>推荐：微臣GRE-张禄</p><ul><li>阅读真题、经典长阅读真题 —— 计时刷</li><li>不必执着真题，按薄弱点找专项训练</li><li>碰到完全看不懂的文章，进行拆句精读</li></ul><h4 id="3-1-GRE阅读考察什么："><a href="#3-1-GRE阅读考察什么：" class="headerlink" title="3.1 GRE阅读考察什么："></a>3.1 GRE阅读考察什么：</h4><ul><li>词汇\短语</li><li>长难句</li><li>抗遗忘能力</li><li>逻辑——关系：句内关系，<strong>句间关系</strong></li><li>做题能力</li></ul><h4 id="3-2-核心方法论"><a href="#3-2-核心方法论" class="headerlink" title="3.2 核心方法论"></a>3.2 核心方法论</h4><ul><li><p>三秒版本：每一句、每一段、每一篇 最核心最概括的版本（抗遗忘能力）</p><ul><li>主干原则<ul><li>简单句：SVO主谓宾</li><li>复合句：主句SVO</li><li>观点句：内容主干</li></ul></li></ul></li><li><p>句间关系：做预判</p><ul><li>取同</li><li>取反<ul><li>But, Yet, H/however, Nevertheless — 出现这几个词就是取反</li><li>换对象</li><li>负态度词：criticize; oppose …</li></ul></li></ul></li><li><p>同义改写</p><ul><li><p>正确的选项 = 正确的同义改写</p></li><li><p>选项中的虚词，要在原文中找指代</p><ul><li>a/an/certain</li><li>可数名词复数</li><li>不可数名词</li></ul></li></ul></li></ul><h4 id="3-3-题型分类"><a href="#3-3-题型分类" class="headerlink" title="3.3 题型分类"></a>3.3 题型分类</h4><ul><li>主旨题 primary purpose : 3s</li><li>细节题<ul><li>可定位细节题 ： according to the passage / in order to</li><li>不可定位细节题：which of the following is mentioned in the passage?</li></ul></li></ul><h4 id="3-4-读文章步骤"><a href="#3-4-读文章步骤" class="headerlink" title="3.4 读文章步骤"></a>3.4 读文章步骤</h4><p>首句 — 翻译 — 3s — 预判 — 第二句 — 翻译 — 3s …</p><h4 id="3-5-核心短语"><a href="#3-5-核心短语" class="headerlink" title="3.5 核心短语"></a>3.5 核心短语</h4><ul><li>stop short of 不做某事</li><li>jockey for 不择手段地争取</li><li>per se 本身，本质上</li><li>silver lining 困境中的一线希望</li><li>in the grip of 受……的重大影响</li><li>bear out 证实</li><li>status quo 原状，现状</li><li>hinge on 取决于</li><li>be pitted against 在与……抗争</li><li>be punctuated by 被……打断</li><li>put another way 换句话说</li><li>to some extent 一定程度上</li><li>for one thing 首先</li><li>set apart 区别开</li><li>come into being 形成</li><li>in spite of 尽管</li><li>accommodate () to 使适应</li><li>prior to 在……之前</li><li>laundry list of 详细清单，一大串……</li><li>have a bearing of 与……有关</li><li>run against 与……竞争</li><li>take sides 选择立场</li><li>gain favor 获得青睐</li><li>gloss over 掩饰，搪塞</li><li>sign into (law) 签署</li><li>shed light on 阐明，帮助理解</li><li>draw support for 为……争取支持</li><li>ensue from 由……产生 = spring from = stem from </li><li>rebel against 反抗，抵抗</li><li>be attributable to 归因于，归结于 = ascribe to </li><li>a salvo of 大量的</li><li>drop out 退出，半途而废</li><li>explain away 通过解释消除</li><li>back and forth 反复，来回</li><li>subject to 受制于，依赖于</li><li>at stake 处于危险中</li><li>leave out 省略，忽略</li><li>frame of reference 参考系</li><li>constitutional monarchy 君主立宪政体</li><li>in proximity to 在……附近</li><li>deduce from 推导，逻辑演绎</li><li>at large 整个的</li><li>touch on 简单提起</li><li>order of magnitude 数量级</li><li>speculate on 提出假设，猜想</li><li>pave the way for 为……铺平了道路</li><li>a streak of 有一点，有一丝</li><li>conform to 符合</li><li>in retrospect 回顾往事，事后看来</li><li>lay out 1. 提出，解释； 2. 部署，布置</li><li>draw from 从……中取得</li><li>make … distinct from 使脱颖而出</li><li>extrapolate from 由……推断；外推</li><li>shore up 加固</li><li>coincide with 同时发生</li><li>so far 1. 到目前为止； <strong>2. 有限地</strong></li><li>as a function of 随着……变化</li><li>set aside 1. 置…不顾； 2. 留出</li><li>figure as 扮演……角色</li><li>pass into oblivion 逐渐被遗忘</li><li>project into 投射，显示</li><li>all but 1. （接名词）除了(-)； 2. （接形容词）几乎(+)</li><li>get credit for 因……而受到好评</li><li>take up 承担，开始做</li><li>lay off 解雇</li><li>fall into disrepute 名声扫地</li><li>not so much A as B 与其说是A不如说是B</li><li>ward off 避开，避免</li><li>be committed to 致力于</li></ul><h3 id="4-数学"><a href="#4-数学" class="headerlink" title="4. 数学"></a>4. 数学</h3><ul><li>视频课，明确考纲范围 ——&gt; 刷真题</li><li>时间充裕者，『猴哥数学难题』</li><li>考察细心程度，看一看网上总结的『中国人容易出错的几个地方』，背一背概率论的几个经典公式</li><li>不要拿『GRE数学高分突破.pdf』or 『GRE数学考点大全.doc』这种生僻难题众多的来打击自信心</li></ul><h3 id="5-作文"><a href="#5-作文" class="headerlink" title="5. 作文"></a>5. 作文</h3><h4 id="Issue-Writing"><a href="#Issue-Writing" class="headerlink" title="Issue Writing"></a>Issue Writing</h4><ul><li>一定要写几篇自己感受。逻辑重要。</li></ul><p>Direction分类 6种</p><ol><li>敌方看法类<ol><li>敌方看法类 challenge - 考虑别人如何反驳自己，批判性思考并解释 - <strong>一定要解释敌方观点的理由和例子</strong></li><li>两种看法类 both - 讨论两种观点并选边 - 需要讨论地方观点，但是不需要解释其理由和例子</li></ol></li><li>分情况做讨论类<ol><li>是非判断 ways - 同意与否相关陈述，尽量批判性讨论，不一边倒</li><li>建议类1 circumstances</li><li>建议类2 consequence</li></ol></li><li>因果类 claim reason</li></ol><ul><li><p>不要生搬硬套例子来佐证观点，可能会不相关。实在没有例子可以适当编造。</p></li><li><p>Issue高频题表和Issue提纲大全，照着高频表把每篇文章的提纲和例子在脑子里飞快过一遍，然后就动笔写</p></li></ul><h4 id="Argument-Writing"><a href="#Argument-Writing" class="headerlink" title="Argument Writing"></a>Argument Writing</h4><ul><li>搜索『Argument中文提纲』，看个十几篇，明白套路</li><li>形成自己的模板</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《GRE核心词汇助记》（再要你命3000）</li></ul><blockquote><p>填空部分保证70%正确率。4道六选二全对，机经可能会中一两道，你自己再做对一两道，正确率不就70%了吗？然后阅读部分错一半，第一个section总共错8个，进入median模式。Median模式难度比第一个section简单，那第二个section少错一点，错6个。这样verbal就能156+了</p><p>对于大部分中国学生而言，Writing部分3.5分差不多够用了，所以也不必把Issue部分看得太重，复习重心还是以Verbal为主。Argument拿4分Issue拿3分就行了，3分多容易啊～随便写写嘛╮(‵▽′)╭～</p><p>最后附上我自己当时的备考schedule：</p><p>1-7天： 飞速刷佛脚单词，看看视频课。</p><p>8-22天： 每天100—150道填空、10—15篇短阅读、1—2篇长阅读。反复刷反复看直到对已有的真题滚瓜烂熟。</p><p>23-25天： 数学和作文。（别学我！作文多留点时间练！）</p><p>作者：皮皮卡    链接：<a href="https://www.zhihu.com/question/19701271/answer/127153648" target="_blank" rel="noopener">https://www.zhihu.com/question/19701271/answer/127153648</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      烦恼少不了，该考还得考
    
    </summary>
    
      <category term="English Learning" scheme="http://bingcs.com/categories/English-Learning/"/>
    
    
      <category term="GRE" scheme="http://bingcs.com/tags/GRE/"/>
    
  </entry>
  
</feed>
